/// <reference types="googlemaps" />
/// <reference types="heremaps" />
import * as Types from '.';
export declare enum GeoMapProvider {
    Google = "Google",
    Here = "Here",
    Custom = "Custom"
}
export declare type LoadMapConfig = LoadGoogleMapConfig | LoadHereMapConfig;
export declare type LoadGoogleMapConfig = LoadGoogleMapConfigBase<GoogleMapApiKeyAuth> | LoadGoogleMapConfigBase<GoogleMapClientIdAuth>;
export declare type GoogleMapAuth = GoogleMapApiKeyAuth | GoogleMapClientIdAuth;
export declare enum GoogleMapAuthType {
    ApiKey = "ApiKey",
    ClientId = "ClientId"
}
export interface GoogleMapApiKeyAuth {
    apiKey: string;
}
export interface GoogleMapClientIdAuth {
    clientId: string;
    channel?: string;
}
export interface LoadGoogleMapConfigBase<T = undefined> {
    language?: string;
    region?: string;
    provider: GeoMapProvider.Google;
    viewport?: GeoMapViewport;
    auth: T;
}
export interface LoadGoogleMapConfigDefault extends LoadGoogleMapConfigBase {
    apiKey: string;
}
export interface LoadHereMapConfig {
    appCode: string;
    appId: string;
    language?: string;
    provider: GeoMapProvider.Here;
    region?: string;
    viewport?: GeoMapViewport;
}
export interface GeoMapViewport {
    top: number;
    right: number;
    bottom: number;
    left: number;
}
export declare type LoadMapResult = LoadGoogleMapResult | LoadHereMapResult | LoadCustomMapResult;
export interface LoadGoogleMapResult {
    result: Types.Result<typeof google.maps>;
    readonly provider: GeoMapProvider.Google;
}
export interface LoadHereMapResult {
    result: Types.Result<typeof H>;
    readonly provider: GeoMapProvider.Here;
}
export interface LoadCustomMapResult {
    result: Types.Result<any>;
    readonly provider: GeoMapProvider.Custom;
}
export interface LoadMapContext {
    window: Window;
    init?(): GeoMapApi;
}
export declare type GeoMapInit = GoogleGeoMapInit | HereGeoMapInit | CustomGeoMapInit;
export declare type GeoMapConfig = LoadGoogleMapConfig | LoadHereMapConfig;
export interface GoogleGeoMapInit {
    implementation: GeoMapImplementation;
    provider: GeoMapProvider.Google;
}
export interface HereGeoMapInit {
    implementation: GeoMapImplementation;
    provider: GeoMapProvider.Here;
}
export interface CustomGeoMapInit {
    implementation: GeoMapImplementation;
    provider: GeoMapProvider.Custom;
}
export interface GeoMapImplementation {
    load(): Promise<LoadMapResult>;
    mount(el: HTMLElement, mountInit: GeoMapMountInit): Promise<void>;
    phase(phase: GeoMapPhase): Promise<void>;
    getCenter(): Promise<GeoPoint>;
    setCenter(center: GeoPoint): Promise<void>;
    getLayer(): Promise<GeoLayer>;
    setLayer(layer: GeoLayer): Promise<void>;
    getMarkers(): Promise<GeoMarkerImplementation[]>;
    getType(): Promise<GeoMapType>;
    setType(type: GeoMapType): Promise<void>;
    setViewport(viewport: GeoMapViewport): Promise<void>;
    getViewBounds(): Promise<GeoBounds>;
    setViewBounds(bounds: GeoBounds): Promise<void>;
    getZoom(): Promise<number>;
    setZoom(zoomFactor: number): Promise<void>;
    addEventListener(eventName: Types.GeoEvent.Click, handler: Types.GeoEventHandler<Types.GeoClickPayload>): Promise<void>;
    addEventListener(eventName: Types.GeoEvent.Changed, handler: Types.GeoEventHandler<void>): Promise<void>;
    addEventListener(name: GeoEvent, handler: Types.GeoEventHandler): Promise<void>;
    coversLocation(point: Types.GeoPoint): Promise<boolean>;
}
export declare enum PlaceType {
    Unknown = 0,
    Removed = 1,
    Car = 2,
    Favorit = 4,
    LastUsed = 8
}
export interface PlaceInit {
    type?: PlaceType;
    readonly id?: string;
}
export interface Place {
    type: PlaceType;
    readonly id: string;
    equal(oth: Place): boolean;
}
export declare type GoogleApi = typeof google.maps;
export declare type HereApi = typeof H;
export declare type GoogleMap = google.maps.Map;
export declare type HereMap = H.Map;
export declare type GeoMapApi = GoogleApi | HereApi;
export interface GeoMapContext extends LoadMapContext {
    changed?(geoMapApi: google.maps.Map | H.Map): Promise<void>;
    load?(config: GeoMapConfig, ctx?: GeoMapContext): Promise<any>;
    loaded?(geoMapApi: google.maps.Map | H.Map, ctx: {
        api: GeoMapApi;
        context: GeoMapContext;
    }): Promise<void>;
}
export interface GeoPoint {
    lat: number;
    lng: number;
}
export interface GeoMapMountInit {
    center: GeoPoint;
    type?: GeoMapType;
    layer?: GeoLayer;
    zoom?: number;
}
export declare enum GeoMapType {
    Roadmap = "Roadmap",
    Hybrid = "Hybrid",
    Unknown = "Unknown"
}
export declare enum GeoLayer {
    Transit = "Transit",
    Traffic = "Traffic",
    None = "None"
}
export interface GeoMarkerImplementation {
    getIcon(): Promise<string>;
    setIcon(svg: string): Promise<Types.Result<void>>;
    getPosition(): Promise<Types.GeoPoint>;
    setPosition(position: GeoPoint): Promise<void>;
    remove(): Promise<void>;
}
export interface GeoMarkerInit {
    provider: GeoMapProvider;
    implementation: GeoMarkerImplementation;
}
export declare enum GeoMarkerOrientation {
    Start = 0,
    Middle = 1,
    End = 2
}
export interface GeoMarkerAnchor {
    vertical: GeoMarkerOrientation;
    horizontal: GeoMarkerOrientation;
}
export interface GeoMarkerConfig {
    anchor?: GeoMarkerAnchor;
    position: GeoPoint;
    icon: string;
}
export interface GeoMarkerCreateInit extends GeoMarkerConfig {
    provider: GeoMapProvider;
    mapImplementation: GeoMapImplementation;
    context?: GeoMapContext;
}
export interface HereMarkerContext {
    mapImplementation: GeoMapImplementation;
    context?: GeoMapContext;
}
export interface GoogleMarkerContext {
    mapImplementation: GeoMapImplementation;
    context?: GeoMapContext;
}
export declare type GeoMarkerContext = HereMarkerContext | GoogleMarkerContext;
export declare enum HerePixelDensity {
    Default = 72,
    HighRes = 320,
    UltraHighRes = 500
}
export declare enum HereLanguage {
    ar = "ara",
    eu = "baq",
    ca = "cat",
    zh = "chi",
    cs = "cze",
    da = "dan",
    nl = "dut",
    en = "eng",
    fi = "fin",
    fr = "fre",
    de = "ger",
    ga = "gle",
    el = "gre",
    he = "heb",
    hi = "hin",
    id = "ind",
    it = "ita",
    no = "nor",
    fa = "per",
    pl = "pol",
    pt = "por",
    ru = "rus",
    si = "sin",
    es = "spa",
    sw = "swe",
    th = "tha",
    tr = "tur",
    uk = "ukr",
    ur = "urd",
    vi = "vie",
    cy = "wel",
    Multiple = "mul"
}
export interface GeoBounds {
    north: number;
    east: number;
    south: number;
    west: number;
}
export interface GeoRectInit {
    implementation: GeoRectImplementation;
    provider: GeoMapProvider;
}
export interface GeoRectCreateInit<T extends GeoMapProvider = GeoMapProvider> extends GeoBounds {
    provider: T;
}
export interface GeoRectImplementation {
    getBounds(): Promise<GeoBounds>;
    coversLocation(point: Types.GeoPoint): Promise<boolean>;
}
export interface RectContext {
    mapImplementation: GeoMapImplementation;
}
export interface CircleContext {
    mapImplementation: GeoMapImplementation;
}
export interface GoogleRectContext {
    api: GoogleApi;
}
export interface HereRectContext {
    api: HereApi;
}
export declare enum GeoMapPhase {
    Pristine = "pristine",
    Loading = "loading",
    Loaded = "loaded",
    Mounting = "mounting",
    Mounted = "mounted",
    Layouting = "layouting",
    Layouted = "layouted"
}
export interface GeoCircleImplementation {
    getBounds(): Promise<GeoBounds>;
}
export interface GeoCircleInit {
    provider: GeoMapProvider;
    implementation: GeoCircleImplementation;
}
export interface GeoCircleCreateInit {
    provider: GeoMapProvider;
    /** LatLng position of the circle's center */
    position: GeoPoint;
    /** Radius of the circle in meters */
    radius: number;
}
export interface GeoCircleConfig {
    /** LatLng position of the circle's center */
    position: GeoPoint;
    /** Radius of the circle in meters */
    radius: number;
}
export declare enum GeoEvent {
    Click = "click",
    Changed = "changed",
    Loaded = "tilesloaded"
}
export declare type GeoEventPayload = GeoClickPayload;
export interface GeoClickPayload {
    position: {
        lat: number;
        lng: number;
    };
}
export declare type GeoEventHandler<T extends GeoEventPayload | void = any> = (e?: T) => void;
export interface GeoMapCodingServiceImplementation {
    reverse(point: GeoPoint): Promise<Types.Result<GeoMapPlaceDetails[]>>;
}
export interface GeoMapDirectionResult {
    start: Types.GeoPoint;
    end: Types.GeoPoint;
}
export interface GeoMapDirectionServiceImplementation {
    /**
     * @param from The route origin
     * @param to The route destination
     * @return The route start- and endpoint of the calculated route.
     *          This may slightly differ from the given start and endpoint.
     */
    paintRoute(from: Types.GeoPoint, to: Types.GeoPoint): Promise<GeoMapDirectionResult>;
    /**
     * Removes all drawings from the map
     */
    clear(): Promise<void>;
}
export interface GeoMapPlacesServiceImplementation {
    get(id: string): Promise<Types.Result<GeoMapPlaceDetails>>;
    search(needle: string, center: Types.GeoPoint, radius: number): Promise<Types.Result<GeoMapPlace[]>>;
    distanceBetween(from: Types.GeoPoint, to: Types.GeoPoint, radius?: number): number;
}
export interface GeoMapPlaceDetails {
    readonly provider: Types.GeoMapProvider;
    readonly id: string;
    readonly name?: string;
    readonly address: {
        readonly country: string | undefined;
        readonly countryCode: string | undefined;
        readonly county: string | undefined;
        readonly district: string | undefined;
        readonly state: string | undefined;
        readonly postalCode: string | undefined;
        readonly locality: string | undefined;
        readonly route: string | undefined;
        readonly streetNumber: string | undefined;
    };
    readonly formattedAddress: string;
    readonly location?: Types.GeoPoint;
    readonly icon?: string;
    readonly permanentlyClosed?: boolean;
    readonly type?: string[];
    readonly formattedPhoneNumber?: string;
    readonly website?: string;
}
export interface GeoMapPlace {
    readonly provider: Types.GeoMapProvider;
    readonly name: string;
    readonly id: string;
    readonly formattedAddress: string;
    readonly location: {
        readonly lat: number;
        readonly lng: number;
    };
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs");
class PackageJson {
    static read(basePath, startPath = '') {
        basePath = path.resolve(basePath);
        startPath = startPath == '' ? basePath : startPath;
        const packageJsonFname = basePath.endsWith('package.json') ? basePath : path.join(basePath, 'package.json');
        if (fs.existsSync(packageJsonFname)) {
            return new PackageJson(JSON.parse(fs.readFileSync(packageJsonFname).toString()));
        }
        if (path.dirname(basePath) == basePath) {
            throw Error(`Unable to find package.json in '${startPath}'`);
        }
        return this.read(path.dirname(basePath), startPath);
    }
    static writeDummy(pkgName, directory, pkgs) {
        const packagesJson = {
            name: pkgName,
            version: '99.98.97',
            main: './lib/index.js',
            license: 'UNLICENSED',
            author: 'composer',
            scripts: {
                start: 'exec node index.js',
                watch: "node -e 'require(\"app-composer\").startWatchComposer(process.cwd())'",
                bootstrap: [
                    'echo "add app-composer dependency"',
                    'yarn add app-composer@1.5.10 --dev --pure-lockfile',
                    'echo "app-composer create buildpack"',
                    'node -e \'require("app-composer").createBuildPack(process.cwd());\'',
                    'echo "install dependencies ..."',
                    'yarn install --pure-lockfile',
                    'echo "install local dependencies and create startup script ..."',
                    'node -e \'require("app-composer").createStartup(process.cwd());\'',
                ].join(' ; ')
            },
            devDependencies: {},
            dependencies: {}
        };
        pkgs.forEach((names) => {
            packagesJson.dependencies[names.packageJson.name] = `${names.packageJson.version}`;
        });
        const packageJsonFname = path.join(directory, 'package.json');
        fs.writeFileSync(packageJsonFname, JSON.stringify(packagesJson, null, 2));
        return packageJsonFname;
    }
    static findPathTo(str) {
        if (str.length === 0) {
            return null;
        }
        const stat = fs.statSync(str);
        if (!stat) {
            throw new Error(`this must be somewhere ${str}`);
        }
        let pjson;
        let base;
        if (stat.isDirectory()) {
            base = str;
            pjson = path.join(base, 'package.json');
        }
        else {
            base = path.dirname(str);
            pjson = path.join(base, 'package.json');
        }
        const ret = fs.existsSync(pjson);
        if (!ret) {
            if (base != path.dirname(base)) {
                return this.findPathTo(path.dirname(base));
            }
            else {
                return null;
            }
        }
        return base;
    }
    static isComposable(schema) {
        return typeof schema !== 'undefined' && !!schema['app-composer'];
    }
    constructor(schema) {
        this.name = schema.name;
        this.version = schema.version;
        this.main = schema.main;
        this.license = schema.license;
        this.author = schema.author;
        this.scripts = schema.scripts;
        this.dependencies = schema.dependencies;
        this.devDependencies = schema.devDependencies;
        this['app-composer'] = schema['app-composer'];
    }
    write(destination) {
        try {
            fs.writeFileSync(destination, JSON.stringify(this, null, 2), 'utf8');
        }
        catch (e) {
            console.log(`unable to write package json to ${destination}`, e);
            throw e;
        }
    }
    mergeDependencies(pkgJson) {
        return new PackageJson({
            name: this.name,
            version: this.version,
            main: this.main,
            license: this.license,
            author: this.author,
            scripts: this.scripts,
            devDependencies: Object.assign({}, this.devDependencies, pkgJson.devDependencies),
            dependencies: Object.assign({}, this.dependencies, pkgJson.dependencies)
        });
    }
    removeDependencies(packageNames) {
        const dependencies = {};
        const devDependencies = {};
        Object.keys(this.dependencies).forEach((depName) => {
            if (packageNames.indexOf(depName) < 0) {
                dependencies[depName] = this.dependencies[depName];
                devDependencies[depName] = this.devDependencies[depName];
            }
        });
        return new PackageJson({
            name: this.name,
            version: this.version,
            main: this.main,
            license: this.license,
            author: this.author,
            scripts: this.scripts,
            devDependencies: devDependencies,
            dependencies: dependencies
        });
    }
}
exports.PackageJson = PackageJson;
//# sourceMappingURL=package-json.js.map
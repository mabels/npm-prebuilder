"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs");
const execa = require("execa");
const mkdirp = require("./folder-creator");
const package_json_1 = require("../types/package-json");
const invoke_package_1 = require("./invoke-package");
const transform_to_compose_1 = require("./transform-to-compose");
const uuid = require("uuid");
function addProjectPackages(pkgDeps, targetFolder, options) {
    if (!options.localDependencies) {
        return;
    }
    Object.keys(options.localDependencies).forEach((dependencyName) => {
        if (pkgDeps && pkgDeps[dependencyName]) {
            const pathToProject = options.localDependencies[dependencyName];
            const packageJson = package_json_1.PackageJson.read(pathToProject);
            if (pack(packageJson.name, pathToProject, targetFolder, options)) {
                addProjectPackages(packageJson.dependencies, targetFolder, options);
            }
        }
    });
}
function pack(pkgName, srcFolder, trgFolder, options) {
    const composeDir = path.join(trgFolder, 'compose');
    const tmpDir = path.join(trgFolder, '.tmp', uuid.v4());
    const pkgFileName = path.join(composeDir, `${pkgName}`);
    const tmpFileName = path.join(tmpDir, `${pkgName}`);
    if (!options.replace && fs.existsSync(`${pkgFileName}.npm.tgz`)) {
        return false;
    }
    console.log(`creating ${pkgFileName}.npm.tgz`);
    mkdirp.sync(path.dirname(pkgFileName));
    mkdirp.sync(path.dirname(tmpFileName));
    execa.sync('yarn', ['pack', '-f', `${tmpFileName}.npm.tgz`, '--silent'], { cwd: srcFolder });
    fs.renameSync(`${tmpFileName}.npm.tgz`, `${pkgFileName}.npm.tgz`);
    return true;
}
exports.pack = pack;
function createPkg(basePath = './', options) {
    const packageJson = package_json_1.PackageJson.read(basePath);
    if (!package_json_1.PackageJson.isComposable(packageJson)) {
        return;
    }
    options = options || { replace: false, localDependencies: {} };
    const appComposer = packageJson['app-composer'];
    const perCompose = transform_to_compose_1.transformToCompose(packageJson, appComposer);
    const composePaths = {};
    perCompose.forEach((entryPoints, composePath) => {
        composePath = path.resolve(basePath, composePath);
        const composeDir = path.join(composePath, 'compose');
        const pkgFname = path.join(composeDir, `${packageJson.name}`);
        pack(packageJson.name, basePath, composePath, options);
        addProjectPackages(packageJson.dependencies, composePath, options);
        composePaths[composePath] = composePath;
        const js = invoke_package_1.invokePackage(basePath, path.basename(pkgFname), entryPoints);
        package_json_1.PackageJson.writeDummy('app-composer', composePath, []);
        fs.writeFileSync(`${pkgFname}.Invocation.json`, JSON.stringify(js.invocation, null, 2));
    });
}
exports.createPkg = createPkg;
//# sourceMappingURL=create-pkg.js.map
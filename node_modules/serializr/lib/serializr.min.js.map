{"version":3,"file":"serializr.min.js","sources":["../src/utils/utils.js","../src/api/getDefaultModelSchema.js","../src/api/setDefaultModelSchema.js","../src/api/createModelSchema.js","../src/types/primitive.js","../src/constants.js","../src/api/serializable.js","../src/core/serialize.js","../src/core/Context.js","../src/core/deserialize.js","../src/types/object.js","../src/types/reference.js","../src/types/list.js","../src/api/createSimpleSchema.js","../src/core/update.js","../src/types/identifier.js","../src/types/date.js","../src/types/alias.js","../src/types/custom.js","../src/types/map.js","../src/types/mapAsArray.js","../src/types/raw.js"],"sourcesContent":["export function GUARDED_NOOP(err) {\n    if (err) // unguarded error...\n        throw new Error(err)\n}\n\nexport function once(fn) {\n    var fired = false\n    return function() {\n        if (!fired) {\n            fired = true\n            return fn.apply(null, arguments)\n        }\n        invariant(false, \"callback was invoked twice\")\n    }\n}\n\nexport function invariant(cond, message) {\n    if (!cond)\n        throw new Error(\"[serializr] \" + (message || \"Illegal State\"))\n}\n\nexport function parallel(ar, processor, cb) {\n  // TODO: limit parallelization?\n    if (ar.length === 0)\n        return void cb(null, [])\n    var left = ar.length\n    var resultArray = []\n    var failed = false\n    var processorCb = function(idx, err, result) {\n        if (err) {\n            if (!failed) {\n                failed = true\n                cb(err)\n            }\n        } else {\n            resultArray[idx] = result\n            if (--left === 0)\n                cb(null, resultArray)\n        }\n    }\n    ar.forEach(function (value, idx) {\n        processor(value, processorCb.bind(null, idx))\n    })\n}\n\nexport function isPrimitive(value) {\n    if (value === null)\n        return true\n    return typeof value !== \"object\" && typeof value !== \"function\"\n}\n\nexport function isModelSchema(thing) {\n    return thing && thing.factory && thing.props\n}\n\nexport function isPropSchema(thing) {\n    return thing && thing.serializer && thing.deserializer\n}\n\nexport function isAliasedPropSchema(propSchema) {\n    return typeof propSchema === \"object\" && !!propSchema.jsonname\n}\n\nexport function isIdentifierPropSchema(propSchema) {\n    return  typeof propSchema === \"object\" && propSchema.identifier === true\n}\n\nexport function isAssignableTo(actualType, expectedType) {\n    while (actualType) {\n        if (actualType === expectedType)\n            return true\n        actualType = actualType.extends\n    }\n    return false\n}\n\nexport function isMapLike(thing) {\n    return thing && typeof thing.keys === \"function\" && typeof thing.clear === \"function\"\n}\n\nexport function getIdentifierProp(modelSchema) {\n    invariant(isModelSchema(modelSchema))\n    // optimization: cache this lookup\n    while (modelSchema) {\n        for (var propName in modelSchema.props)\n            if (typeof modelSchema.props[propName] === \"object\" && modelSchema.props[propName].identifier === true)\n                return propName\n        modelSchema = modelSchema.extends\n    }\n    return null\n}\n","import { isModelSchema } from \"../utils/utils\"\n\n/**\n * Returns the standard model schema associated with a class / constructor function\n *\n * @param {object} thing\n * @returns {ModelSchema} model schema\n */\nexport default function getDefaultModelSchema(thing) {\n    if (!thing)\n        return null\n    if (isModelSchema(thing))\n        return thing\n    if (isModelSchema(thing.serializeInfo))\n        return thing.serializeInfo\n    if (thing.constructor && thing.constructor.serializeInfo)\n        return thing.constructor.serializeInfo\n}\n","import { invariant, isModelSchema } from \"../utils/utils\"\n\n/**\n * Sets the default model schema for class / constructor function.\n * Everywhere where a model schema is required as argument, this class / constructor function\n * can be passed in as well (for example when using `object` or `ref`.\n *\n * When passing an instance of this class to `serialize`, it is not required to pass the model schema\n * as first argument anymore, because the default schema will be inferred from the instance type.\n *\n * @param {constructor|class} clazz class or constructor function\n * @param {ModelSchema} modelSchema - a model schema\n * @returns {ModelSchema} model schema\n */\nexport default function setDefaultModelSchema(clazz, modelSchema) {\n    invariant(isModelSchema(modelSchema))\n    return clazz.serializeInfo = modelSchema\n}\n","import { invariant } from \"../utils/utils\"\nimport getDefaultModelSchema from \"./getDefaultModelSchema\"\nimport setDefaultModelSchema from \"./setDefaultModelSchema\"\n\n/**\n * Creates a model schema that (de)serializes an object created by a constructor function (class).\n * The created model schema is associated by the targeted type as default model schema, see setDefaultModelSchema.\n * Its factory method is `() => new clazz()` (unless overriden, see third arg).\n *\n * @example\n * function Todo(title, done) {\n *     this.title = title;\n *     this.done = done;\n * }\n *\n * createModelSchema(Todo, {\n *     title: true,\n *     done: true,\n * });\n *\n * var json = serialize(new Todo('Test', false));\n * var todo = deserialize(Todo, json);\n *\n * @param {constructor|class} clazz class or constructor function\n * @param {object} props property mapping\n * @param {function} factory optional custom factory. Receives context as first arg\n * @returns {object} model schema\n */\nexport default function createModelSchema(clazz, props, factory) {\n    invariant(clazz !== Object, \"one cannot simply put define a model schema for Object\")\n    invariant(typeof clazz === \"function\", \"expected constructor function\")\n    var model = {\n        targetClass: clazz,\n        factory: factory || function() {\n            return new clazz()\n        },\n        props: props\n    }\n  // find super model\n    if (clazz.prototype.constructor !== Object) {\n        var s = getDefaultModelSchema(clazz.prototype.constructor)\n        if (s && s.targetClass !== clazz)\n            model.extends = s\n    }\n    setDefaultModelSchema(clazz, model)\n    return model\n}\n","import { invariant } from \"../utils/utils\"\nimport { isPrimitive } from \"../utils/utils\"\n\n/**\n * Indicates that this field contains a primitive value (or Date) which should be serialized literally to json.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: primitive(),\n * });\n *\n * console.dir(serialize(new Todo('test')));\n * // outputs: { title : \"test\" }\n *\n * @returns {ModelSchema}\n */\nexport default function primitive() {\n    return {\n        serializer: function (value) {\n            invariant(isPrimitive(value), \"this value is not primitive: \" + value)\n            return value\n        },\n        deserializer: function (jsonValue, done) {\n            if (!isPrimitive(jsonValue))\n                return void done(\"[serializr] this value is not primitive: \" + jsonValue)\n            return void done(null, jsonValue)\n        }\n    }\n}\n","import primitive from \"./types/primitive\"\n\n/**\n * In the event that a property needs to be deserialized, but not serialized, you can use the SKIP symbol to omit the property. This has to be used with the custom serializer.\n *\n * @example\n * var schema = _.createSimpleSchema({\n *     a: _.custom(\n *         function(v) {\n *             return _.SKIP\n *         },\n *         function(v) {\n *             return v;\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(s, { a: 4 }), { });\n * t.deepEqual(_.deserialize(s, { a: 4 }), { a: 4 });\n */\nexport var SKIP = typeof Symbol !== \"undefined\" ? Symbol(\"SKIP\") : { SKIP: true }\n\nexport var _defaultPrimitiveProp = primitive()\n","import { invariant, isPropSchema } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\nimport primitive from \"../types/primitive\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport createModelSchema from \"../api/createModelSchema\"\n\n// Ugly way to get the parameter names since they aren't easily retrievable via reflection\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg\nvar ARGUMENT_NAMES = /([^\\s,]+)/g\n\nfunction getParamNames(func) {\n    var fnStr = func.toString().replace(STRIP_COMMENTS, \"\")\n    var result = fnStr.slice(fnStr.indexOf(\"(\")+1, fnStr.indexOf(\")\")).match(ARGUMENT_NAMES)\n    if(result === null)\n        result = []\n    return result\n}\n\nfunction serializableDecorator(propSchema, target, propName, descriptor) {\n    invariant(arguments.length >= 2, \"too few arguments. Please use @serializable as property decorator\")\n    // Fix for @serializable used in class constructor params (typescript)\n    var factory\n    if (propName === undefined && typeof target === \"function\"\n        && target.prototype\n        && descriptor !== undefined && typeof descriptor === \"number\") {\n        invariant(isPropSchema(propSchema), \"Constructor params must use alias(name)\")\n        invariant(propSchema.jsonname, \"Constructor params must use alias(name)\")\n        var paramNames = getParamNames(target)\n        if (paramNames.length >= descriptor) {\n            propName = paramNames[descriptor]\n            propSchema.paramNumber = descriptor\n            descriptor = undefined\n            target = target.prototype\n            // Create a factory so the constructor is called properly\n            factory = function(context) {\n                var params = []\n                for (var i = 0; i < target.constructor.length; i++) {\n                    Object.keys(context.modelSchema.props).forEach(function (key) {\n                        var prop = context.modelSchema.props[key]\n                        if (prop.paramNumber === i) {\n                            params[i] = context.json[prop.jsonname]\n                        }\n                    })\n                }\n\n                return new (Function.prototype.bind.apply(target.constructor, [null].concat(params)))\n            }\n        }\n    }\n    invariant(typeof propName === \"string\", \"incorrect usage of @serializable decorator\")\n    var info = getDefaultModelSchema(target)\n\n    if (!info || !target.constructor.hasOwnProperty(\"serializeInfo\"))\n        info = createModelSchema(target.constructor, {}, factory)\n    if (info && info.targetClass !== target.constructor)\n        // fixes typescript issue that tends to copy fields from super constructor to sub constructor in extends\n        info = createModelSchema(target.constructor, {}, factory)\n    info.props[propName] = propSchema\n    // MWE: why won't babel work without?\n    if (descriptor && !descriptor.get && !descriptor.set)\n        descriptor.writable = true\n    return descriptor\n}\n\n/**\n * Decorator that defines a new property mapping on the default model schema for the class\n * it is used in.\n *\n * When using typescript, the decorator can also be used on fields declared as constructor arguments (using the `private` / `protected` / `public` keywords).\n * The default factory will then invoke the constructor with the correct arguments as well.\n *\n * @example\n * class Todo {\n *     @serializable(primitive())\n *     title; // shorthand for primitves\n *\n *     @serializable done;\n *\n *     constructor(title, done) {\n *         this.title = title;\n *         this.done = done;\n *     }\n * }\n *\n * var json = serialize(new Todo('Test', false));\n * var todo = deserialize(Todo, json);\n *\n * @param arg1\n * @param arg2\n * @param arg3\n * @returns {PropertyDescriptor}\n */\nexport default function serializable(arg1, arg2, arg3) {\n    if (arguments.length === 1) {\n        // decorated with propSchema\n        var propSchema = arg1 === true ? _defaultPrimitiveProp : arg1\n        invariant(isPropSchema(propSchema), \"@serializable expects prop schema\")\n        return serializableDecorator.bind(null, propSchema)\n    } else {\n        // decorated without arguments, treat as primitive\n        return serializableDecorator(primitive(), arg1, arg2, arg3)\n    }\n}\n","import { invariant, isPrimitive } from \"../utils/utils\"\nimport createModelSchema from \"../api/createModelSchema\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport setDefaultModelSchema from \"../api/setDefaultModelSchema\"\nimport { SKIP, _defaultPrimitiveProp } from \"../constants\"\n\n/**\n * Serializes an object (graph) into json using the provided model schema.\n * The model schema can be omitted if the object type has a default model schema associated with it.\n * If a list of objects is provided, they should have an uniform type.\n *\n * @param arg1 modelschema to use. Optional\n * @param arg2 object(s) to serialize\n * @returns {object} serialized representation of the object\n */\nexport default function serialize(arg1, arg2) {\n    invariant(arguments.length === 1 || arguments.length === 2, \"serialize expects one or 2 arguments\")\n    var thing = arguments.length === 1 ? arg1 : arg2\n    var schema = arguments.length === 1 ? null : arg1\n    if (Array.isArray(thing)) {\n        if (thing.length === 0)\n            return [] // don't bother finding a schema\n        else if (!schema)\n            schema = getDefaultModelSchema(thing[0])\n    } else if (!schema) {\n        schema = getDefaultModelSchema(thing)\n    }\n    invariant(!!schema, \"Failed to find default schema for \" + arg1)\n    if (Array.isArray(thing))\n        return thing.map(function (item) {\n            return serializeWithSchema(schema, item)\n        })\n    return serializeWithSchema(schema, thing)\n}\n\nexport function serializeWithSchema(schema, obj) {\n    invariant(schema && typeof schema === \"object\", \"Expected schema\")\n    invariant(obj && typeof obj === \"object\", \"Expected object\")\n    var res\n    if (schema.extends)\n        res = serializeWithSchema(schema.extends, obj)\n    else {\n        // TODO: make invariant?:  invariant(!obj.constructor.prototype.constructor.serializeInfo, \"object has a serializable supertype, but modelschema did not provide extends clause\")\n        res = {}\n    }\n    Object.keys(schema.props).forEach(function (key) {\n        var propDef = schema.props[key]\n        if (key === \"*\") {\n            invariant(propDef === true, \"prop schema '*' can onle be used with 'true'\")\n            serializeStarProps(schema, obj, res)\n            return\n        }\n        if (propDef === true)\n            propDef = _defaultPrimitiveProp\n        if (propDef === false)\n            return\n        var jsonValue = propDef.serializer(obj[key], key, obj)\n        if (jsonValue === SKIP){\n            return\n        }\n        res[propDef.jsonname || key] = jsonValue\n    })\n    return res\n}\n\nexport function serializeStarProps(schema, obj, target) {\n    for (var key in obj) if (obj.hasOwnProperty(key)) if (!(key in schema.props)) {\n        var value = obj[key]\n        // when serializing only serialize primitive props. Assumes other props (without schema) are local state that doesn't need serialization\n        if (isPrimitive(value))\n            target[key] = value\n    }\n}\n\n/**\n * The `serializeAll` decorator can be used on a class to signal that all primitive properties should be serialized automatically.\n *\n * @example\n * @serializeAll class Store {\n *     a = 3;\n *     b;\n * }\n *\n * const store = new Store();\n * store.c = 5;\n * store.d = {};\n * t.deepEqual(serialize(store), { a: 3, b: undefined, c: 5 });\n */\nexport function serializeAll(target) {\n    invariant(arguments.length === 1 && typeof target === \"function\", \"@serializeAll can only be used as class decorator\")\n\n    var info = getDefaultModelSchema(target)\n    if (!info || !target.hasOwnProperty(\"serializeInfo\")) {\n        info = createModelSchema(target, {})\n        setDefaultModelSchema(target, info)\n    }\n\n    getDefaultModelSchema(target).props[\"*\"] = true\n    return target\n}\n","import { GUARDED_NOOP, once, invariant, isAssignableTo } from \"../utils/utils\"\n\nexport default function Context(parentContext, modelSchema, json, onReadyCb, customArgs) {\n    this.parentContext = parentContext\n    this.isRoot = !parentContext\n    this.pendingCallbacks = 0\n    this.pendingRefsCount = 0\n    this.onReadyCb = onReadyCb || GUARDED_NOOP\n    this.json = json\n    this.target = null\n    this.hasError = false\n    this.modelSchema = modelSchema\n    if (this.isRoot) {\n        this.rootContext = this\n        this.args = customArgs\n        this.pendingRefs = {} // uuid: [{ modelSchema, uuid, cb }]\n        this.resolvedRefs = {} // uuid: [{ modelSchema, value }]\n    } else {\n        this.rootContext = parentContext.rootContext\n        this.args = parentContext.args\n    }\n}\n\nContext.prototype.createCallback = function (fn) {\n    this.pendingCallbacks++\n    // once: defend against user-land calling 'done' twice\n    return once(function(err, value) {\n        if (err) {\n            if (!this.hasError) {\n                this.hasError = true\n                this.onReadyCb(err)\n            }\n        } else if (!this.hasError) {\n            fn(value)\n            if (--this.pendingCallbacks === this.pendingRefsCount) {\n                if (this.pendingRefsCount > 0)\n                  // all pending callbacks are pending reference resolvers. not good.\n                    this.onReadyCb(new Error(\n                      \"Unresolvable references in json: \\\"\" +\n                      Object.keys(this.pendingRefs).filter(function (uuid) {\n                          return this.pendingRefs[uuid].length > 0\n                      }, this).join(\"\\\", \\\"\") +\n                       \"\\\"\"\n                  ))\n                else\n                  this.onReadyCb(null, this.target)\n            }\n        }\n    }.bind(this))\n}\n\n// given an object with uuid, modelSchema, callback, awaits until the given uuid is available\n// resolve immediately if possible\nContext.prototype.await = function (modelSchema, uuid, callback) {\n    invariant(this.isRoot)\n    if (uuid in this.resolvedRefs) {\n        var match = this.resolvedRefs[uuid].filter(function (resolved) {\n            return isAssignableTo(resolved.modelSchema, modelSchema)\n        })[0]\n        if (match)\n            return void callback(null, match.value)\n    }\n    this.pendingRefsCount++\n    if (!this.pendingRefs[uuid])\n        this.pendingRefs[uuid] = []\n    this.pendingRefs[uuid].push({\n        modelSchema: modelSchema,\n        uuid: uuid,\n        callback: callback\n    })\n}\n\n// given a model schema, uuid and value, resolve all references that where looking for this object\nContext.prototype.resolve = function(modelSchema, uuid, value) {\n    invariant(this.isRoot)\n    if (!this.resolvedRefs[uuid])\n        this.resolvedRefs[uuid] = []\n    this.resolvedRefs[uuid].push({\n        modelSchema: modelSchema, value: value\n    })\n    if (uuid in this.pendingRefs) {\n        for (var i = this.pendingRefs[uuid].length - 1; i >= 0; i--) {\n            var opts = this.pendingRefs[uuid][i]\n            if (isAssignableTo(modelSchema, opts.modelSchema)) {\n                this.pendingRefs[uuid].splice(i, 1)\n                this.pendingRefsCount--\n                opts.callback(null, value)\n            }\n        }\n    }\n}","/*\n * Deserialization\n */\nimport { invariant, isPrimitive, isModelSchema, parallel, GUARDED_NOOP } from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport { SKIP, _defaultPrimitiveProp } from \"../constants\"\nimport Context from \"./Context\"\n\nfunction schemaHasAlias(schema, name) {\n    for (var key in schema.props)\n        if (typeof schema.props[key] === \"object\" && schema.props[key].jsonname === name)\n            return true\n    return false\n}\n\nfunction deserializeStarProps(schema, obj, json) {\n    for (var key in json) if (!(key in schema.props) && !schemaHasAlias(schema, key)) {\n        var value = json[key]\n        // when deserializing we don't want to silently ignore 'unparseable data' to avoid confusing bugs\n        invariant(isPrimitive(value), \"encountered non primitive value while deserializing '*' properties in property '\" + key + \"': \" + value)\n        obj[key] = value\n    }\n}\n\n/**\n * Deserializes a json structor into an object graph.\n * This process might be asynchronous (for example if there are references with an asynchronous\n * lookup function). The function returns an object (or array of objects), but the returned object\n * might be incomplete until the callback has fired as well (which might happen immediately)\n *\n * @param {object|array} schema to use for deserialization\n * @param {json} json data to deserialize\n * @param {function} callback node style callback that is invoked once the deserializaiton has finished.\n * First argument is the optional error, second argument is the deserialized object (same as the return value)\n * @param {*} customArgs custom arguments that are available as `context.args` during the deserialization process. This can be used as dependency injection mechanism to pass in, for example, stores.\n * @returns {object|array} deserialized object, possibly incomplete.\n */\nexport default function deserialize(schema, json, callback, customArgs) {\n    invariant(arguments.length >= 2, \"deserialize expects at least 2 arguments\")\n    schema = getDefaultModelSchema(schema)\n    invariant(isModelSchema(schema), \"first argument should be model schema\")\n    if (Array.isArray(json)) {\n        var items = []\n        parallel(\n            json,\n            function (childJson, itemDone) {\n                var instance = deserializeObjectWithSchema(null, schema, childJson, itemDone, customArgs)\n                // instance is created synchronously so can be pushed\n                items.push(instance)\n            },\n            callback || GUARDED_NOOP\n        )\n        return items\n    } else\n  return deserializeObjectWithSchema(null, schema, json, callback, customArgs)\n}\n\nexport function deserializeObjectWithSchema(parentContext, schema, json, callback, customArgs) {\n    if (json === null || json === undefined)\n        return void callback(null, null)\n    var context = new Context(parentContext, schema, json, callback, customArgs)\n    var target = schema.factory(context)\n    // todo async invariant\n    invariant(!!target, \"No object returned from factory\")\n    // TODO: make invariant?            invariant(schema.extends || !target.constructor.prototype.constructor.serializeInfo, \"object has a serializable supertype, but modelschema did not provide extends clause\")\n    context.target = target\n    var lock = context.createCallback(GUARDED_NOOP)\n    deserializePropsWithSchema(context, schema, json, target)\n    lock()\n    return target\n}\n\nexport function deserializePropsWithSchema(context, schema, json, target) {\n    if (schema.extends)\n        deserializePropsWithSchema(context, schema.extends, json, target)\n    Object.keys(schema.props).forEach(function (propName) {\n        var propDef = schema.props[propName]\n        if (propName === \"*\") {\n            invariant(propDef === true, \"prop schema '*' can onle be used with 'true'\")\n            deserializeStarProps(schema, target, json)\n            return\n        }\n        if (propDef === true)\n            propDef = _defaultPrimitiveProp\n        if (propDef === false)\n            return\n        var jsonAttr = propDef.jsonname || propName\n        if (!(jsonAttr in json))\n            return\n        propDef.deserializer(\n            json[jsonAttr],\n            // for individual props, use root context based callbacks\n            // this allows props to complete after completing the object itself\n            // enabling reference resolving and such\n            context.rootContext.createCallback(function (value) {\n                if (value !== SKIP){\n                    target[propName] = value\n                }\n            }),\n            context,\n            target[propName] // initial value\n        )\n    })\n}\n","import { invariant, isModelSchema } from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport serialize from \"../core/serialize\"\nimport { deserializeObjectWithSchema } from \"../core/deserialize\"\n\n/**\n * `object` indicates that this property contains an object that needs to be (de)serialized\n * using its own model schema.\n *\n * N.B. mind issues with circular dependencies when importing model schema's from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n *\n * @example\n * class SubTask {}\n * class Todo {}\n *\n * createModelSchema(SubTask, {\n *     title: true,\n * });\n * createModelSchema(Todo, {\n *     title: true,\n *     subTask: object(SubTask),\n * });\n *\n * const todo = deserialize(Todo, {\n *     title: 'Task',\n *     subTask: {\n *         title: 'Sub task',\n *     },\n * });\n *\n * @param {ModelSchema} modelSchema to be used to (de)serialize the object\n * @returns {PropSchema}\n */\nexport default function object(modelSchema) {\n    invariant(typeof modelSchema === \"object\" || typeof modelSchema === \"function\", \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\")\n    return {\n        serializer: function (item) {\n            modelSchema = getDefaultModelSchema(modelSchema)\n            invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema)\n            if (item === null || item === undefined)\n                return item\n            return serialize(modelSchema, item)\n        },\n        deserializer: function (childJson, done, context) {\n            modelSchema = getDefaultModelSchema(modelSchema)\n            invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema)\n            if (childJson === null || childJson === undefined)\n                return void done(null, childJson)\n            return void deserializeObjectWithSchema(context, modelSchema, childJson, done)\n        }\n    }\n}\n","import { invariant, isModelSchema, getIdentifierProp } from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\n\nfunction createDefaultRefLookup(modelSchema) {\n    return function resolve(uuid, cb, context) {\n        context.rootContext.await(modelSchema, uuid, cb)\n    }\n}\n\n/**\n * `reference` can be used to (de)serialize references that point to other models.\n *\n * The first parameter should be either a ModelSchema that has an `identifier()` property (see identifier)\n * or a string that represents which attribute in the target object represents the identifier of the object.\n *\n * The second parameter is a lookup function that is invoked during deserialization to resolve an identifier to\n * an object. Its signature should be as follows:\n *\n * `lookupFunction(identifier, callback, context)` where:\n * 1. `identifier` is the identifier being resolved\n * 2. `callback` is a node style calblack function to be invoked with the found object (as second arg) or an error (first arg)\n * 3. `context` see context.\n *\n * The lookupFunction is optional. If it is not provided, it will try to find an object of the expected type and required identifier within the same JSON document\n *\n * N.B. mind issues with circular dependencies when importing model schemas from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n *\n * @example\n * class User {}\n * class Post {}\n *\n * createModelSchema(User, {\n *     uuid: identifier(),\n *     displayname: primitive(),\n * });\n *\n * createModelSchema(Post, {\n *     author: reference(User, findUserById),\n *     message: primitive(),\n * });\n *\n * function findUserById(uuid, callback) {\n *     fetch('http://host/user/' + uuid)\n *         .then(userData => {\n *             deserialize(User, userData, callback);\n *         })\n *         .catch(callback);\n * }\n *\n * deserialize(\n *     Post,\n *     {\n *         message: 'Hello World',\n *         author: 234,\n *     },\n *     (err, post) => {\n *         console.log(post);\n *     }\n * );\n *\n * @param target: ModelSchema or string\n * @param {RefLookupFunction} lookupFn function\n * @returns {PropSchema}\n */\nexport default function reference(target, lookupFn) {\n    invariant(!!target, \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\")\n    var initialized = false\n    var childIdentifierAttribute\n    function initialize() {\n        initialized = true\n        invariant(typeof target !== \"string\" || lookupFn, \"if the reference target is specified by attribute name, a lookup function is required\")\n        invariant(!lookupFn || typeof lookupFn === \"function\", \"second argument should be a lookup function\")\n        if (typeof target === \"string\")\n            childIdentifierAttribute = target\n        else {\n            var modelSchema = getDefaultModelSchema(target)\n            invariant(isModelSchema(modelSchema), \"expected model schema or string as first argument for 'ref', got \" + modelSchema)\n            lookupFn = lookupFn || createDefaultRefLookup(modelSchema)\n            childIdentifierAttribute = getIdentifierProp(modelSchema)\n            invariant(!!childIdentifierAttribute, \"provided model schema doesn't define an identifier() property and cannot be used by 'ref'.\")\n        }\n    }\n    return {\n        serializer: function (item) {\n            if (!initialized)\n                initialize()\n            return item ? item[childIdentifierAttribute] : null\n        },\n        deserializer: function(identifierValue, done, context) {\n            if (!initialized)\n                initialize()\n            if (identifierValue === null || identifierValue === undefined)\n                done(null, identifierValue)\n            else\n                lookupFn(identifierValue, done, context)\n        }\n    }\n}\n","import { invariant, isPropSchema, isAliasedPropSchema, parallel } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\n\n/**\n * List indicates that this property contains a list of things.\n * Accepts a sub model schema to serialize the contents\n *\n * @example\n * class SubTask {}\n * class Task {}\n * class Todo {}\n *\n * createModelSchema(SubTask, {\n *     title: true,\n * });\n * createModelSchema(Todo, {\n *     title: true,\n *     subTask: list(object(SubTask)),\n * });\n *\n * const todo = deserialize(Todo, {\n *     title: 'Task',\n *     subTask: [\n *         {\n *             title: 'Sub task 1',\n *         },\n *     ],\n * });\n *\n * @param {PropSchema} propSchema to be used to (de)serialize the contents of the array\n * @returns {PropSchema}\n */\nexport default function list(propSchema) {\n    propSchema = propSchema || _defaultPrimitiveProp\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\")\n    invariant(!isAliasedPropSchema(propSchema), \"provided prop is aliased, please put aliases first\")\n    return {\n        serializer: function (ar) {\n            invariant(ar && \"length\" in ar && \"map\" in ar, \"expected array (like) object\")\n            return ar.map(propSchema.serializer)\n        },\n        deserializer: function(jsonArray, done, context) {\n            if (!Array.isArray(jsonArray))\n                return void done(\"[serializr] expected JSON array\")\n            parallel(\n                jsonArray,\n                function (item, itemDone) {\n                    return propSchema.deserializer(item, itemDone, context)\n                },\n                done\n            )\n        }\n    }\n}\n","/**\n * Creates a model schema that (de)serializes from / to plain javascript objects.\n * Its factory method is: `() => ({})`\n *\n * @example\n * var todoSchema = createSimpleSchema({\n *     title: true,\n *     done: true,\n * });\n *\n * var json = serialize(todoSchema, { title: 'Test', done: false });\n * var todo = deserialize(todoSchema, json);\n *\n * @param {object} props property mapping,\n * @returns {object} model schema\n */\nexport default function createSimpleSchema(props) {\n    return {\n        factory: function() {\n            return {}\n        },\n        props: props\n    }\n}\n","/*\n * Update\n */\n\nimport { invariant, isModelSchema, GUARDED_NOOP } from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport Context from \"./Context\"\nimport { deserializePropsWithSchema } from \"./deserialize\"\n\n/**\n * Similar to deserialize, but updates an existing object instance.\n * Properties will always updated entirely, but properties not present in the json will be kept as is.\n * Further this method behaves similar to deserialize.\n *\n * @param {object} modelSchema, optional if it can be inferred from the instance type\n * @param {object} target target instance to update\n * @param {object} json the json to deserialize\n * @param {function} callback the callback to invoke once deserialization has completed.\n * @param {*} customArgs custom arguments that are available as `context.args` during the deserialization process. This can be used as dependency injection mechanism to pass in, for example, stores.\n */\nexport default function update(modelSchema, target, json, callback, customArgs) {\n    var inferModelSchema =\n        arguments.length === 2 // only target and json\n        || typeof arguments[2] === \"function\" // callback as third arg\n\n    if (inferModelSchema) {\n        target = arguments[0]\n        modelSchema = getDefaultModelSchema(target)\n        json = arguments[1]\n        callback = arguments[2]\n        customArgs = arguments[3]\n    } else {\n        modelSchema = getDefaultModelSchema(modelSchema)\n    }\n    invariant(isModelSchema(modelSchema), \"update failed to determine schema\")\n    invariant(typeof target === \"object\" && target && !Array.isArray(target), \"update needs an object\")\n    var context = new Context(null, modelSchema, json, callback, customArgs)\n    context.target = target\n    var lock = context.createCallback(GUARDED_NOOP)\n    deserializePropsWithSchema(context, modelSchema, json, target)\n    lock()\n}\n","import { invariant } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\n\nfunction defaultRegisterFunction(id, value, context) {\n    context.rootContext.resolve(context.modelSchema, id, context.target)\n}\n\n/**\n *\n *\n * Similar to primitive, but this field will be marked as the identifier for the given Model type.\n * This is used by for example `reference()` to serialize the reference\n *\n * Identifier accepts an optional `registerFn` with the signature:\n * `(id, target, context) => void`\n * that can be used to register this object in some store. note that not all fields of this object might\n * have been deserialized yet.\n *\n * @example\n * var todos = {};\n * \n * var s = _.createSimpleSchema({\n *     id: _.identifier((id, object) => (todos[id] = object)),\n *     title: true,\n * });\n * \n * _.deserialize(s, {\n *     id: 1,\n *     title: 'test0',\n * });\n * _.deserialize(s, [{ id: 2, title: 'test2' }, { id: 1, title: 'test1' }]);\n * \n * t.deepEqual(todos, {\n *     1: { id: 1, title: 'test1' },\n *     2: { id: 2, title: 'test2' },\n * });\n *\n * @param {RegisterFunction} registerFn optional function to register this object during creation.\n *\n * @returns {PropSchema}\n */\nexport default function identifier(registerFn) {\n    invariant(!registerFn || typeof registerFn === \"function\", \"First argument should be omitted or function\")\n    return {\n        identifier: true,\n        serializer: _defaultPrimitiveProp.serializer,\n        deserializer: function (jsonValue, done, context) {\n            _defaultPrimitiveProp.deserializer(jsonValue, function(err, id) {\n                defaultRegisterFunction(id, context.target, context)\n                if (registerFn)\n                    registerFn(id, context.target, context)\n                done(err, id)\n            })\n        }\n    }\n}","import { invariant } from \"../utils/utils\"\n\n/**\n * Similar to primitive, serializes instances of Date objects\n *\n * @returns\n */\nexport default function date() {\n  // TODO: add format option?\n    return {\n        serializer: function(value) {\n            if (value === null || value === undefined)\n                return value\n            invariant(value instanceof Date, \"Expected Date object\")\n            return value.getTime()\n        },\n        deserializer: function (jsonValue, done) {\n            if (jsonValue === null || jsonValue === undefined)\n                return void done(null, jsonValue)\n            return void done(null, new Date(jsonValue))\n        }\n    }\n}\n","import { invariant, isPropSchema, isAliasedPropSchema, isIdentifierPropSchema } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\n\n/**\n * Alias indicates that this model property should be named differently in the generated json.\n * Alias should be the outermost propschema.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: alias('task', primitive()),\n * });\n *\n * console.dir(serialize(new Todo('test')));\n * // { task : \"test\" }\n *\n * @param {string} name name of the json field to be used for this property\n * @param {PropSchema} propSchema propSchema to (de)serialize the contents of this field\n * @returns {PropSchema}\n */\nexport default function alias(name, propSchema) {\n    invariant(name && typeof name === \"string\", \"expected prop name as first argument\")\n    propSchema = (!propSchema || propSchema === true)  ? _defaultPrimitiveProp : propSchema\n    invariant(isPropSchema(propSchema), \"expected prop schema as second argument\")\n    invariant(!isAliasedPropSchema(propSchema), \"provided prop is already aliased\")\n    return {\n        jsonname: name,\n        serializer: propSchema.serializer,\n        deserializer: propSchema.deserializer,\n        identifier: isIdentifierPropSchema(propSchema)\n    }\n}\n","import {invariant} from \"../utils/utils\"\n\n/**\n * Can be used to create simple custom propSchema. Multiple things can be done inside of a custom propSchema, like deserializing and serializing other (polymorphic) objects, skipping the serialization of something or checking the context of the obj being (de)serialized.\n\n * The `custom` function takes two parameters, the `serializer` function and the `deserializer` function.\n\n * The `serializer` function has the signature:\n * `(value, key, obj) => void`\n\n * When serializing the object `{a: 1}` the `serializer` function will be called with `serializer(1, 'a', {a: 1})`.\n\n * The `deserializer` function has the following signature for synchronous processing\n * `(value, context, oldValue) => void`\n\n * For asynchronous processing the function expects the following signature\n * `(value, context, oldValue, callback) => void`\n\n * When deserializing the object `{b: 2}` the `deserializer` function will be called with `deserializer(2, contextObj)` ([contextObj reference](https://github.com/mobxjs/serializr#deserialization-context)).\n *\n * @example\n * var schemaDefault = _.createSimpleSchema({\n *     a: _.custom(\n *         function(v) {\n *             return v + 2;\n *         },\n *         function(v) {\n *             return v - 2;\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(schemaDefault, { a: 4 }), { a: 6 });\n * t.deepEqual(_.deserialize(schemaDefault, { a: 6 }), { a: 4 });\n *\n * var schemaWithAsyncProps = _.createSimpleSchema({\n *     a: _.customAsync(\n *         function(v) {\n *             return v + 2;\n *         },\n *         function(v, context, oldValue, callback) {\n *             somePromise(v, context, oldValue).then((result) => {\n *                 callback(null, result - 2)\n *             }.catch((err) => {\n *                 callback(err)\n *             }\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(schemaWithAsyncProps, { a: 4 }), { a: 6 });\n * _.deserialize(schemaWithAsyncProps, { a: 6 }, (err, res) => {\n *   t.deepEqual(res.a, 4)\n * };\n\n *\n * @param {function} serializer function that takes a model value and turns it into a json value\n * @param {function} deserializer function that takes a json value and turns it into a model value. It also takes context argument, which can allow you to deserialize based on the context of other parameters.\n * @returns {PropSchema}\n */\nexport default function custom(serializer, deserializer) {\n    invariant(typeof serializer === \"function\", \"first argument should be function\")\n    invariant((typeof deserializer === \"function\"), \"second argument should be a function or promise\")\n    return {\n        serializer: serializer,\n        deserializer: function (jsonValue, done, context, oldValue) {\n            if (deserializer.length === 4) {\n                deserializer(jsonValue, context, oldValue, done)\n            } else {\n                done(null, deserializer(jsonValue, context, oldValue))\n            }\n        }\n    }\n}\n","import { invariant, isAliasedPropSchema, isPropSchema, isMapLike } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\nimport list from \"./list\"\n\n/**\n* Similar to list, but map represents a string keyed dynamic collection.\n* This can be both plain objects (default) or ES6 Map like structures.\n* This will be inferred from the initial value of the targetted attribute.\n*\n* @param {*} propSchema\n* @returns\n*/\nexport default function map(propSchema) {\n    propSchema = propSchema || _defaultPrimitiveProp\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\")\n    invariant(!isAliasedPropSchema(propSchema), \"provided prop is aliased, please put aliases first\")\n    return {\n        serializer: function (m) {\n            invariant(m && typeof m === \"object\", \"expected object or Map\")\n            var isMap = isMapLike(m)\n            var result = {}\n            if (isMap)\n                m.forEach(function(value, key) {\n                    result[key] = propSchema.serializer(value)\n                })\n            else for (var key in m)\n                result[key] = propSchema.serializer(m[key])\n            return result\n        },\n        deserializer: function(jsonObject, done, context, oldValue) {\n            if (!jsonObject || typeof jsonObject !== \"object\")\n                return void done(\"[serializr] expected JSON object\")\n            var keys = Object.keys(jsonObject)\n            list(propSchema).deserializer(\n              keys.map(function (key) {\n                  return jsonObject[key]\n              }),\n              function (err, values) {\n                  if (err)\n                      return void done(err)\n                  var isMap = isMapLike(oldValue)\n                  var newValue\n                  if (isMap) {\n                      // if the oldValue is a map, we recycle it\n                      // there are many variations and this way we don't have to\n                      // know about the original constructor\n                      oldValue.clear()\n                      newValue = oldValue\n                  } else\n                      newValue = {}\n                  for (var i = 0, l = keys.length; i < l; i++)\n                      if (isMap)\n                          newValue.set(keys[i], values[i])\n                      else\n                          newValue[keys[i]] = values[i]\n                  done(null, newValue)\n              },\n              context\n          )\n        }\n    }\n}\n","import { invariant, isPropSchema, isMapLike } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\nimport list from \"./list\"\n\n/**\n * Similar to map, mapAsArray can be used to serialize a map-like collection where the key is contained in the 'value object'.\n * Example: consider Map<id: number, customer: Customer> where the Customer object has the id stored on itself.\n * mapAsArray stores all values from the map into an array which is serialized.\n * Deserialization returns a ES6 Map or plain object object where the `keyPropertyName` of each object is used for keys.\n * For ES6 maps this has the benefit of being allowed to have non-string keys in the map. The serialized json also may be slightly more compact.\n *\n * @param {any} propSchema, {string} keyPropertyName - the property of stored objects used as key in the map\n * @returns\n */\nexport default function mapAsArray(propSchema, keyPropertyName) {\n    propSchema = propSchema || _defaultPrimitiveProp\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\")\n    invariant(!!keyPropertyName, \"expected key property name as second argument\")\n    return {\n        serializer: function (m) {\n            var result = []\n            // eslint-disable-next-line no-unused-vars\n            m.forEach(function (value, key) {\n                result.push(propSchema.serializer(value))\n            })\n            return result\n        },\n        deserializer: function (jsonArray, done, context, oldValue) {\n            list(propSchema).deserializer(\n              jsonArray,\n              function (err, values) {\n                  if (err)\n                      return void done(err)\n                  var isMap = isMapLike(oldValue)\n                  var newValue\n                  if (isMap) {\n                      oldValue.clear()\n                      newValue = oldValue\n                  } else\n                      newValue = {}\n                  for (var i = 0, l = jsonArray.length; i < l; i++)\n                      if (isMap)\n                          newValue.set(values[i][keyPropertyName], values[i])\n                      else\n                          newValue[values[i][keyPropertyName].toString()] = values[i]\n                  done(null, newValue)\n              },\n              context\n          )\n        }\n    }\n}\n","/**\n * Indicates that this field is only need to putted in the serialized json or\n * deserialized instance, without any transformations. Stay with its original value\n *\n * @example\n * createModelSchema(Model, {\n *     rawData: raw(),\n * });\n *\n * console.dir(serialize(new Model({ rawData: { a: 1, b: [], c: {} } } })));\n * // outputs: { rawData: { a: 1, b: [], c: {} } } }\n *\n * @returns {ModelSchema}\n */\nexport default function raw() {\n    return {\n        serializer: function (value) {\n            return value\n        },\n        deserializer: function (jsonValue, done) {\n            return void done(null, jsonValue)\n        }\n    }\n}\n"],"names":["GUARDED_NOOP","err","Error","invariant","cond","message","parallel","ar","processor","cb","length","left","resultArray","failed","forEach","value","idx","result","bind","isPrimitive","isModelSchema","thing","factory","props","isPropSchema","serializer","deserializer","isAliasedPropSchema","propSchema","jsonname","isAssignableTo","actualType","expectedType","extends","isMapLike","keys","clear","getDefaultModelSchema","serializeInfo","constructor","setDefaultModelSchema","clazz","modelSchema","createModelSchema","Object","model","targetClass","prototype","s","primitive","jsonValue","done","SKIP","Symbol","_defaultPrimitiveProp","STRIP_COMMENTS","ARGUMENT_NAMES","serializableDecorator","target","propName","descriptor","fnStr","arguments","undefined","paramNames","toString","replace","slice","indexOf","match","paramNumber","context","params","i","key","prop","json","Function","apply","concat","info","hasOwnProperty","get","set","writable","serialize","arg1","arg2","schema","Array","isArray","map","item","serializeWithSchema","obj","res","propDef","serializeStarProps","Context","parentContext","onReadyCb","customArgs","this","isRoot","pendingCallbacks","pendingRefsCount","hasError","rootContext","args","pendingRefs","resolvedRefs","schemaHasAlias","name","deserializeObjectWithSchema","callback","lock","createCallback","deserializePropsWithSchema","deserializeStarProps","jsonAttr","object","childJson","reference","lookupFn","childIdentifierAttribute","initialized","initialize","uuid","await","identifier","getIdentifierProp","identifierValue","list","jsonArray","itemDone","fn","filter","join","fired","resolved","push","resolve","opts","splice","arg3","items","instance","registerFn","id","Date","getTime","oldValue","m","isMap","jsonObject","values","newValue","l","keyPropertyName"],"mappings":"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"}
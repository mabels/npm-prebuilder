"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var indent_1 = require("../indent");
function graphqlOutputFromType(schema, t, out, level) {
    if (out === void 0) { out = []; }
    if (level === void 0) { level = 0; }
    if (t.getFields) {
        Object.entries(t.getFields()).forEach(function (_a) {
            var _ = _a[0], v = _a[1];
            var ql = v;
            if (!(ql.name && ql.type)) {
                throw new Error("graphqlOutputFromType can not traverse without name and type");
            }
            // const found = schema.getTypeMap()[clean(ql.type)] as GraphQLObjectType;
            // const o = [];
            // for (const i in ql.type) {
            //   o.push(i, typeof i, (ql.type as any)[i]);
            // }
            var found = ql.type;
            if (ql.type.ofType) {
                found = ql.type.ofType;
            }
            // console.log(ql.type, typeof ql.type, o);
            if (found && found.getFields) {
                // console.log(v, typeof(found), ql.type, found.getFields);
                out.push(indent_1.indent(level, ql.name + " {"));
                graphqlOutputFromType(schema, found, out, level + 1);
                out.push(indent_1.indent(level, "}"));
            }
            else {
                out.push(indent_1.indent(level, ql.name));
            }
        });
    }
    else {
        out.push(t.name);
    }
    return out.join('\n');
}
exports.graphqlOutputFromType = graphqlOutputFromType;
/*
export function generateOutputFromSchema(
  schema: GraphQLSchema,
  t: GraphQLObjectType
): () => string {
  return () => {
    return graphqlOutputFromType(schema, t);
  };
}
*/
//# sourceMappingURL=graphql-output-from-type.js.map
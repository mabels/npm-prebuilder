'use strict';

var glob = function () {
	var _ref2 = _asyncToGenerator(function* (pattern) {
		var files = yield (0, _globby2.default)([_path2.default.join(__dirname, pattern)], {
			ignore: ['**/index.js', '**/*.test.js'],
			cwd: __dirname
		});
		return files.map(relative).map(toExport);
	});

	return function glob(_x2) {
		return _ref2.apply(this, arguments);
	};
}();

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _ava = require('ava');

var _ava2 = _interopRequireDefault(_ava);

var _globby = require('globby');

var _globby2 = _interopRequireDefault(_globby);

var _lodash = require('lodash');

var _ = require('.');

var _2 = _interopRequireDefault(_);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

(0, _ava2.default)('exports all rules', function () {
	var _ref = _asyncToGenerator(function* (t) {
		var expected = yield glob('*.js');
		var actual = Object.keys(_2.default);
		t.deepEqual(actual, expected);
	});

	return function (_x) {
		return _ref.apply(this, arguments);
	};
}());

(0, _ava2.default)('rules export functions', function (t) {
	var actual = (0, _lodash.values)(_2.default);
	t.true(actual.every(function (rule) {
		return typeof rule === 'function';
	}));
});

function relative(filePath) {
	return _path2.default.relative(__dirname, filePath);
}

function toExport(fileName) {
	return _path2.default.basename(fileName, _path2.default.extname(fileName));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydWxlcy9pbmRleC50ZXN0LmpzIl0sIm5hbWVzIjpbInBhdHRlcm4iLCJmaWxlcyIsImpvaW4iLCJfX2Rpcm5hbWUiLCJpZ25vcmUiLCJjd2QiLCJtYXAiLCJyZWxhdGl2ZSIsInRvRXhwb3J0IiwiZ2xvYiIsInQiLCJleHBlY3RlZCIsImFjdHVhbCIsIk9iamVjdCIsImtleXMiLCJkZWVwRXF1YWwiLCJ0cnVlIiwiZXZlcnkiLCJydWxlIiwiZmlsZVBhdGgiLCJmaWxlTmFtZSIsImJhc2VuYW1lIiwiZXh0bmFtZSJdLCJtYXBwaW5ncyI6Ijs7OytCQWlCQSxXQUFvQkEsT0FBcEIsRUFBNkI7QUFDNUIsTUFBTUMsUUFBUSxNQUFNLHNCQUFPLENBQUMsZUFBS0MsSUFBTCxDQUFVQyxTQUFWLEVBQXFCSCxPQUFyQixDQUFELENBQVAsRUFBd0M7QUFDM0RJLFdBQVEsQ0FBQyxhQUFELEVBQWdCLGNBQWhCLENBRG1EO0FBRTNEQyxRQUFLRjtBQUZzRCxHQUF4QyxDQUFwQjtBQUlBLFNBQU9GLE1BQU1LLEdBQU4sQ0FBVUMsUUFBVixFQUFvQkQsR0FBcEIsQ0FBd0JFLFFBQXhCLENBQVA7QUFDQSxFOztpQkFOY0MsSTs7Ozs7QUFqQmY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBRUEsbUJBQUssbUJBQUw7QUFBQSw4QkFBMEIsV0FBTUMsQ0FBTixFQUFXO0FBQ3BDLE1BQU1DLFdBQVcsTUFBTUYsS0FBSyxNQUFMLENBQXZCO0FBQ0EsTUFBTUcsU0FBU0MsT0FBT0MsSUFBUCxZQUFmO0FBQ0FKLElBQUVLLFNBQUYsQ0FBWUgsTUFBWixFQUFvQkQsUUFBcEI7QUFDQSxFQUpEOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU1BLG1CQUFLLHdCQUFMLEVBQStCLGFBQUs7QUFDbkMsS0FBTUMsU0FBUywrQkFBZjtBQUNBRixHQUFFTSxJQUFGLENBQU9KLE9BQU9LLEtBQVAsQ0FBYTtBQUFBLFNBQVEsT0FBT0MsSUFBUCxLQUFnQixVQUF4QjtBQUFBLEVBQWIsQ0FBUDtBQUNBLENBSEQ7O0FBYUEsU0FBU1gsUUFBVCxDQUFrQlksUUFBbEIsRUFBNEI7QUFDM0IsUUFBTyxlQUFLWixRQUFMLENBQWNKLFNBQWQsRUFBeUJnQixRQUF6QixDQUFQO0FBQ0E7O0FBRUQsU0FBU1gsUUFBVCxDQUFrQlksUUFBbEIsRUFBNEI7QUFDM0IsUUFBTyxlQUFLQyxRQUFMLENBQWNELFFBQWQsRUFBd0IsZUFBS0UsT0FBTCxDQUFhRixRQUFiLENBQXhCLENBQVA7QUFDQSIsImZpbGUiOiJpbmRleC50ZXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgdGVzdCBmcm9tICdhdmEnO1xuaW1wb3J0IGdsb2JieSBmcm9tICdnbG9iYnknO1xuaW1wb3J0IHt2YWx1ZXN9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgcnVsZXMgZnJvbSAnLic7XG5cbnRlc3QoJ2V4cG9ydHMgYWxsIHJ1bGVzJywgYXN5bmMgdCA9PiB7XG5cdGNvbnN0IGV4cGVjdGVkID0gYXdhaXQgZ2xvYignKi5qcycpO1xuXHRjb25zdCBhY3R1YWwgPSBPYmplY3Qua2V5cyhydWxlcyk7XG5cdHQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpO1xufSk7XG5cbnRlc3QoJ3J1bGVzIGV4cG9ydCBmdW5jdGlvbnMnLCB0ID0+IHtcblx0Y29uc3QgYWN0dWFsID0gdmFsdWVzKHJ1bGVzKTtcblx0dC50cnVlKGFjdHVhbC5ldmVyeShydWxlID0+IHR5cGVvZiBydWxlID09PSAnZnVuY3Rpb24nKSk7XG59KTtcblxuYXN5bmMgZnVuY3Rpb24gZ2xvYihwYXR0ZXJuKSB7XG5cdGNvbnN0IGZpbGVzID0gYXdhaXQgZ2xvYmJ5KFtwYXRoLmpvaW4oX19kaXJuYW1lLCBwYXR0ZXJuKV0sIHtcblx0XHRpZ25vcmU6IFsnKiovaW5kZXguanMnLCAnKiovKi50ZXN0LmpzJ10sXG5cdFx0Y3dkOiBfX2Rpcm5hbWVcblx0fSk7XG5cdHJldHVybiBmaWxlcy5tYXAocmVsYXRpdmUpLm1hcCh0b0V4cG9ydCk7XG59XG5cbmZ1bmN0aW9uIHJlbGF0aXZlKGZpbGVQYXRoKSB7XG5cdHJldHVybiBwYXRoLnJlbGF0aXZlKF9fZGlybmFtZSwgZmlsZVBhdGgpO1xufVxuXG5mdW5jdGlvbiB0b0V4cG9ydChmaWxlTmFtZSkge1xuXHRyZXR1cm4gcGF0aC5iYXNlbmFtZShmaWxlTmFtZSwgcGF0aC5leHRuYW1lKGZpbGVOYW1lKSk7XG59XG4iXX0=
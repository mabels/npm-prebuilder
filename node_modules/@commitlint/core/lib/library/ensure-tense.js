'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _pos = require('pos');

var _lodash = require('lodash');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lexer = new _pos.Lexer();
var tagger = new _pos.Tagger();

var tenses = {
	'past-tense': ['VB', 'VBD'],
	'present-imperative': ['VB', 'VBN', 'VBP'],
	'present-participle': ['VB', 'VBG'],
	'present-third-person': ['VB', 'VBZ']
};

function getLemmata(input) {
	try {
		return lexer.lex(input);
	} catch (err) {
		return [];
	}
}

function getTags(lemmata) {
	try {
		return tagger.tag(lemmata);
	} catch (err) {
		return [];
	}
}

exports.default = function (input, allowed) {
	var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	var lemmata = getLemmata(input);
	var tagged = getTags(lemmata);
	var verbs = tagged.filter(function (tag) {
		return tag[1][0] === 'V';
	});
	var tags = allowed.reduce(function (registry, name) {
		return [].concat((0, _toConsumableArray3.default)(registry), (0, _toConsumableArray3.default)(tenses[name] || []));
	}, []);

	var offending = verbs.filter(function (verb) {
		var _verb = (0, _slicedToArray3.default)(verb, 2),
		    tag = _verb[1];

		return tags.length > 0 && tags.indexOf(tag) === -1;
	}).filter(function (verb) {
		var _verb2 = (0, _slicedToArray3.default)(verb, 1),
		    word = _verb2[0];

		return !(options.ignored || []).some(function (ignored) {
			return ignored.indexOf(word) > -1;
		});
	}).filter(Boolean).map(function (verb) {
		var _verb3 = (0, _slicedToArray3.default)(verb, 2),
		    lemma = _verb3[0],
		    tag = _verb3[1];

		var tense = (0, _lodash.entries)(tenses).filter(function (item) {
			var _item = (0, _slicedToArray3.default)(item, 2),
			    tags = _item[1];

			return tags.indexOf(tag) > -1;
		}).map(function (item) {
			return item[0];
		})[0];

		return {
			lemma,
			tense
		};
	});

	return {
		matches: offending.length === 0,
		offending
	};
};

module.exports = exports['default'];
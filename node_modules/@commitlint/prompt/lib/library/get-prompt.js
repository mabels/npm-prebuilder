'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _enumRuleIsActive = require('./enum-rule-is-active');

var _enumRuleIsActive2 = _interopRequireDefault(_enumRuleIsActive);

var _format = require('./format');

var _format2 = _interopRequireDefault(_format);

var _getForcedCase = require('./get-forced-case');

var _getForcedCase2 = _interopRequireDefault(_getForcedCase);

var _getForcedCaseFn = require('./get-forced-case-fn');

var _getForcedCaseFn2 = _interopRequireDefault(_getForcedCaseFn);

var _getForcedLeadingFn = require('./get-forced-leading-fn');

var _getForcedLeadingFn2 = _interopRequireDefault(_getForcedLeadingFn);

var _getHasName = require('./get-has-name');

var _getHasName2 = _interopRequireDefault(_getHasName);

var _meta = require('./meta');

var _meta2 = _interopRequireDefault(_meta);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = getPrompt;

/**
 * Get a cli prompt based on rule configuration
 * @param  {string} type     type of the data to gather
 * @param  {object} context     rules to parse
 * @return {object}          prompt instance
 */

function getPrompt(type) {
	var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	var _context$rules = context.rules,
	    rules = _context$rules === undefined ? [] : _context$rules,
	    _context$settings = context.settings,
	    settings = _context$settings === undefined ? {} : _context$settings,
	    _context$results = context.results,
	    results = _context$results === undefined ? {} : _context$results,
	    prompter = context.prompter;


	if (typeof prompter !== 'function') {
		throw new TypeError('Missing prompter function in getPrompt context');
	}

	var prompt = prompter();

	if (typeof prompt.removeAllListeners !== 'function') {
		throw new TypeError('getPrompt: prompt.removeAllListeners is not a function');
	}

	if (typeof prompt.command !== 'function') {
		throw new TypeError('getPrompt: prompt.command is not a function');
	}

	if (typeof prompt.catch !== 'function') {
		throw new TypeError('getPrompt: prompt.catch is not a function');
	}

	if (typeof prompt.addListener !== 'function') {
		throw new TypeError('getPrompt: prompt.addListener is not a function');
	}

	if (typeof prompt.log !== 'function') {
		throw new TypeError('getPrompt: prompt.log is not a function');
	}

	if (typeof prompt.delimiter !== 'function') {
		throw new TypeError('getPrompt: prompt.delimiter is not a function');
	}

	if (typeof prompt.show !== 'function') {
		throw new TypeError('getPrompt: prompt.show is not a function');
	}

	var enumRule = rules.filter((0, _getHasName2.default)('enum')).filter(_enumRuleIsActive2.default)[0];

	var emptyRule = rules.filter((0, _getHasName2.default)('empty'))[0];

	var mustBeEmpty = emptyRule ? emptyRule[1][0] > 0 && emptyRule[1][1] === 'always' : false;

	var mayNotBeEmpty = emptyRule ? emptyRule[1][0] > 0 && emptyRule[1][1] === 'never' : false;

	var mayBeEmpty = !mayNotBeEmpty;

	if (mustBeEmpty) {
		prompt.removeAllListeners('keypress');
		prompt.removeAllListeners('client_prompt_submit');
		prompt.ui.redraw.done();
		return Promise.resolve();
	}

	var caseRule = rules.filter((0, _getHasName2.default)('case'))[0];

	var forcedCase = (0, _getForcedCase2.default)(caseRule);
	var forceCaseFn = (0, _getForcedCaseFn2.default)(caseRule);

	var leadingBlankRule = rules.filter((0, _getHasName2.default)('leading-blank'))[0];

	var forceLeadingBlankFn = (0, _getForcedLeadingFn2.default)(leadingBlankRule);

	var maxLenghtRule = rules.filter((0, _getHasName2.default)('max-length'))[0];

	var hasMaxLength = maxLenghtRule && maxLenghtRule[1][0] > 0;

	var inputMaxLength = hasMaxLength ? maxLenghtRule[1][1] : Infinity;

	var headerLength = settings.header ? settings.header.length : Infinity;

	var remainingHeaderLength = headerLength ? headerLength - [results.type, results.scope, results.scope ? '()' : '', results.type && results.scope ? ':' : '', results.subject].join('').length : Infinity;

	var maxLength = Math.min(inputMaxLength, remainingHeaderLength);

	return new Promise(function (resolve) {
		// Add the defined enums as sub commands if applicable
		if (enumRule) {
			var _enumRule = (0, _slicedToArray3.default)(enumRule, 2),
			    _enumRule$ = (0, _slicedToArray3.default)(_enumRule[1], 3),
			    enums = _enumRule$[2];

			enums.forEach(function (enumerable) {
				var enumSettings = (settings.enumerables || {})[enumerable] || {};
				prompt.command(enumerable).description(enumSettings.description || '').action(function () {
					prompt.removeAllListeners();
					prompt.ui.redraw.done();
					return resolve(forceLeadingBlankFn(forceCaseFn(enumerable)));
				});
			});
		} else {
			prompt.catch('[text...]').action(function (parameters) {
				var _parameters$text = parameters.text,
				    text = _parameters$text === undefined ? '' : _parameters$text;

				prompt.removeAllListeners();
				prompt.ui.redraw.done();
				return resolve(forceLeadingBlankFn(forceCaseFn(text.join(' '))));
			});
		}

		if (mayBeEmpty) {
			// Add an easy exit command
			prompt.command(':skip').description('Skip the input if possible.').action(function () {
				prompt.removeAllListeners();
				prompt.ui.redraw.done();
				resolve('');
			});
		}

		// Handle empty input
		var onSubmit = function onSubmit(input) {
			if (input.length > 0) {
				return;
			}

			// Show help if enum is defined and input may not be empty
			if (mayNotBeEmpty) {
				prompt.ui.log(_chalk2.default.yellow(`⚠ ${_chalk2.default.bold(type)} may not be empty.`));
			}

			if (mayBeEmpty) {
				prompt.ui.log(_chalk2.default.blue(`ℹ Enter ${_chalk2.default.bold(':skip')} to omit ${_chalk2.default.bold(type)}.`));
			}

			if (enumRule) {
				prompt.exec('help');
			}
		};

		var drawRemaining = function drawRemaining(length) {
			if (length < Infinity) {
				var colors = [{
					threshold: 5,
					color: 'red'
				}, {
					threshold: 10,
					color: 'yellow'
				}, {
					threshold: Infinity,
					color: 'grey'
				}];

				var color = colors.filter(function (item) {
					return item.threshold >= length;
				}).map(function (item) {
					return item.color;
				})[0];

				prompt.ui.redraw(_chalk2.default[color](`${length} characters left`));
			}
		};

		var onKey = function onKey(event) {
			var sanitized = forceCaseFn(event.value);
			var cropped = sanitized.slice(0, maxLength);

			// We **could** do live editing, but there are some quirks to solve
			/* const live = merge({}, results, {
   	[type]: cropped
   });
   prompt.ui.redraw(`\n\n${format(live, true)}\n\n`); */

			if (maxLength) {
				drawRemaining(maxLength - cropped.length);
			}
			prompt.ui.input(cropped);
		};

		prompt.addListener('keypress', onKey);
		prompt.addListener('client_prompt_submit', onSubmit);

		prompt.log(`\n\nPlease enter a ${_chalk2.default.bold(type)}: ${(0, _meta2.default)({
			optional: !mayNotBeEmpty,
			required: mayNotBeEmpty,
			'tab-completion': typeof enumRule !== 'undefined',
			header: typeof settings.header !== 'undefined',
			case: forcedCase,
			'multi-line': settings.multiline
		})}`);

		if (settings.description) {
			prompt.log(_chalk2.default.grey(`${settings.description}\n`));
		}

		prompt.log(`\n\n${(0, _format2.default)(results, true)}\n\n`);

		drawRemaining(maxLength);

		prompt.delimiter(`❯ ${type}:`).show();
	});
}
module.exports = exports['default'];
Function.prototype.$asyncbind = function $asyncbind(self, catcher) {
  "use strict";

  if (!Function.prototype.$asyncbind) {
    Object.defineProperty(Function.prototype, "$asyncbind", {
      value: $asyncbind,
      enumerable: false,
      configurable: true,
      writable: true
    });
  }

  if (!$asyncbind.trampoline) {
    $asyncbind.trampoline = function trampoline(t, x, s, e, u) {
      return function b(q) {
        while (q) {
          if (q.then) {
            q = q.then(b, e);
            return u ? undefined : q;
          }

          try {
            if (q.pop) {
              if (q.length) return q.pop() ? x.call(t) : q;
              q = s;
            } else q = q.call(t);
          } catch (r) {
            return e(r);
          }
        }
      };
    };
  }

  if (!$asyncbind.LazyThenable) {
    $asyncbind.LazyThenable = function () {
      function isThenable(obj) {
        return obj && obj instanceof Object && typeof obj.then === "function";
      }

      function resolution(p, r, how) {
        try {
          var x = how ? how(r) : r;
          if (p === x) return p.reject(new TypeError("Promise resolution loop"));

          if (isThenable(x)) {
            x.then(function (y) {
              resolution(p, y);
            }, function (e) {
              p.reject(e);
            });
          } else {
            p.resolve(x);
          }
        } catch (ex) {
          p.reject(ex);
        }
      }

      function Chained() {}

      ;
      Chained.prototype = {
        resolve: _unchained,
        reject: _unchained,
        then: thenChain
      };

      function _unchained(v) {}

      function thenChain(res, rej) {
        this.resolve = res;
        this.reject = rej;
      }

      function then(res, rej) {
        var chain = new Chained();

        try {
          this._resolver(function (value) {
            return isThenable(value) ? value.then(res, rej) : resolution(chain, value, res);
          }, function (ex) {
            resolution(chain, ex, rej);
          });
        } catch (ex) {
          resolution(chain, ex, rej);
        }

        return chain;
      }

      function Thenable(resolver) {
        this._resolver = resolver;
        this.then = then;
      }

      ;

      Thenable.resolve = function (v) {
        return Thenable.isThenable(v) ? v : {
          then: function then(resolve) {
            return resolve(v);
          }
        };
      };

      Thenable.isThenable = isThenable;
      return Thenable;
    }();

    $asyncbind.EagerThenable = $asyncbind.Thenable = ($asyncbind.EagerThenableFactory = function (tick) {
      tick = tick || typeof process === "object" && process.nextTick || typeof setImmediate === "function" && setImmediate || function (f) {
        setTimeout(f, 0);
      };

      var soon = function () {
        var fq = [],
            fqStart = 0,
            bufferSize = 1024;

        function callQueue() {
          while (fq.length - fqStart) {
            try {
              fq[fqStart]();
            } catch (ex) {}

            fq[fqStart++] = undefined;

            if (fqStart === bufferSize) {
              fq.splice(0, bufferSize);
              fqStart = 0;
            }
          }
        }

        return function (fn) {
          fq.push(fn);
          if (fq.length - fqStart === 1) tick(callQueue);
        };
      }();

      function Zousan(func) {
        if (func) {
          var me = this;
          func(function (arg) {
            me.resolve(arg);
          }, function (arg) {
            me.reject(arg);
          });
        }
      }

      Zousan.prototype = {
        resolve: function resolve(value) {
          if (this.state !== undefined) return;
          if (value === this) return this.reject(new TypeError("Attempt to resolve promise with self"));
          var me = this;

          if (value && (typeof value === "function" || typeof value === "object")) {
            try {
              var first = 0;
              var then = value.then;

              if (typeof then === "function") {
                then.call(value, function (ra) {
                  if (!first++) {
                    me.resolve(ra);
                  }
                }, function (rr) {
                  if (!first++) {
                    me.reject(rr);
                  }
                });
                return;
              }
            } catch (e) {
              if (!first) this.reject(e);
              return;
            }
          }

          this.state = STATE_FULFILLED;
          this.v = value;
          if (me.c) soon(function () {
            for (var n = 0, l = me.c.length; n < l; n++) STATE_FULFILLED(me.c[n], value);
          });
        },
        reject: function reject(reason) {
          if (this.state !== undefined) return;
          this.state = STATE_REJECTED;
          this.v = reason;
          var clients = this.c;
          if (clients) soon(function () {
            for (var n = 0, l = clients.length; n < l; n++) STATE_REJECTED(clients[n], reason);
          });
        },
        then: function then(onF, onR) {
          var p = new Zousan();
          var client = {
            y: onF,
            n: onR,
            p: p
          };

          if (this.state === undefined) {
            if (this.c) this.c.push(client);else this.c = [client];
          } else {
            var s = this.state,
                a = this.v;
            soon(function () {
              s(client, a);
            });
          }

          return p;
        }
      };

      function STATE_FULFILLED(c, arg) {
        if (typeof c.y === "function") {
          try {
            var yret = c.y.call(undefined, arg);
            c.p.resolve(yret);
          } catch (err) {
            c.p.reject(err);
          }
        } else c.p.resolve(arg);
      }

      function STATE_REJECTED(c, reason) {
        if (typeof c.n === "function") {
          try {
            var yret = c.n.call(undefined, reason);
            c.p.resolve(yret);
          } catch (err) {
            c.p.reject(err);
          }
        } else c.p.reject(reason);
      }

      Zousan.resolve = function (val) {
        if (val && val instanceof Zousan) return val;
        var z = new Zousan();
        z.resolve(val);
        return z;
      };

      Zousan.reject = function (err) {
        if (err && err instanceof Zousan) return err;
        var z = new Zousan();
        z.reject(err);
        return z;
      };

      Zousan.version = "2.3.3-nodent";
      return Zousan;
    })();
  }

  var resolver = this;

  switch (catcher) {
    case true:
      return new $asyncbind.Thenable(boundThen);

    case 0:
      return new $asyncbind.LazyThenable(boundThen);

    case undefined:
      boundThen.then = boundThen;
      return boundThen;

    default:
      return function () {
        try {
          return resolver.apply(self, arguments);
        } catch (ex) {
          return catcher(ex);
        }
      };
  }

  function boundThen() {
    return resolver.apply(self, arguments);
  }
};

function _sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return _sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }

const path = require("path");

const url = require("url");

const globby = require("globby");

const loadSourceMap = require("load-source-map");

const pFilter = require("p-filter");

const sander = require("@marionebl/sander");

const _require = require("@patternplate/load-manifest"),
      loadManifest = _require.loadManifest,
      PATTERNPLATE_ERR_NO_MANIFEST = _require.PATTERNPLATE_ERR_NO_MANIFEST;

const loadDoc = require("@patternplate/load-doc");

const PATTERNPLATE_ERROR_DUPE_PATTERN = 'PATTERNPLATE_ERROR_DUPE_PATTERN';
const DEFAULT_MANIFEST = {
  displayName: "",
  version: "1.0.0",
  build: true,
  display: true,
  flag: "alpha",
  options: {},
  patterns: {}
};
module.exports = loadMeta;
module.exports.PATTERNPLATE_ERROR_DUPE_PATTERN = PATTERNPLATE_ERROR_DUPE_PATTERN;

function loadMeta(options) {
  return new Promise(function ($return, $error) {
    var list, entries, pairs;
    return globby(options.entry, {
      cwd: options.cwd
    }).then(function ($await_4) {
      list = $await_4;
      return Promise.all(list.map(bundle => new Promise(function ($return, $error) {
        var file, map;
        file = path.join(options.cwd, bundle);
        return getSourceMap(file).then(function ($await_5) {
          map = $await_5;
          return $return({
            path: file,
            map
          });
        }.$asyncbind(this, $error), $error);
      }.$asyncbind(this)))).then(function ($await_6) {
        entries = $await_6;
        return entries.reduce((accp, b) => new Promise(function ($return, $error) {
          var acc, artifact, pair, sources;
          return accp.then(function ($await_7) {
            acc = $await_7;
            artifact = path.relative(options.cwd, b.path);

            if (!b.map) {
              pair = {
                artifact,
                source: artifact
              };
              acc.push(pair);
              return $return(acc);
            }

            return Promise.all(b.map.sources.map(s => new Promise(function ($return, $error) {
              var _url$parse, p, pa, resolved;

              _url$parse = url.parse(s), p = _url$parse.path;
              pa = path.resolve(path.dirname(b.path), p);
              return sander.exists(pa).then(function ($await_8) {
                if ($await_8) {
                  return $return({
                    artifact,
                    source: pa
                  });
                }

                resolved = path.join(b.map.sourceRoot || options.cwd, pa);
                return sander.exists(resolved).then(function ($await_9) {
                  if ($await_9) {
                    return $return({
                      artifact,
                      source: resolved
                    });
                  }

                  return $return();
                }.$asyncbind(this, $error), $error);
              }.$asyncbind(this, $error), $error);
            }.$asyncbind(this)))).then(function ($await_10) {
              sources = $await_10;
              Array.prototype.push.apply(acc, sources.filter(Boolean));
              return $return(acc);
            }.$asyncbind(this, $error), $error);
          }.$asyncbind(this, $error), $error);
        }.$asyncbind(this)), Promise.resolve([])).then(function ($await_11) {
          pairs = $await_11;
          return pairs.filter(({
            source
          }) => {
            const extname = path.extname(source);
            const dirname = path.dirname(source);
            return path.basename(source, path.extname(source)) === 'demo' || !pairs.some(p => path.dirname(p.source) === dirname);
          }).reduce((accing, pair) => new Promise(function ($return, $error) {
            var acc, source, artifact, cwd, _ref, _ref2, result, file, data, raw, base, relativeManifestPath, manifest, previous, relPath, _ref3, contents;

            let err;
            return accing.then(function ($await_12) {
              acc = $await_12;
              source = pair.source, artifact = pair.artifact;
              cwd = path.resolve(options.cwd, path.dirname(source));
              return json({
                cwd
              }).then(function ($await_13) {
                _ref = $await_13, _ref2 = _slicedToArray(_ref, 2), err = _ref2[0], result = _ref2[1];

                if (err) {
                  if (err.errno !== PATTERNPLATE_ERR_NO_MANIFEST) {
                    acc.errors.push(err);
                  }

                  return $return(acc);
                }

                file = result.file, data = result.manifest, raw = result.raw;
                base = path.dirname(path.relative(options.cwd, cwd));
                relativeManifestPath = path.relative(options.cwd, file);

                if (acc.patterns.some(p => relativeManifestPath === p.path)) {
                  return $return(acc);
                }

                data.displayName = data.displayName || data.name || null;
                manifest = Object.assign({}, DEFAULT_MANIFEST, data);
                previous = acc.patterns.find(pattern => pattern.id === manifest.name);

                if (previous) {
                  relPath = path.relative(process.cwd(), file);
                  let err;
                  err = new Error(`Found duplicated pattern "${previous.id}" at "${relPath}" already present at "${previous.path}"`);
                  err.errno = PATTERNPLATE_ERROR_DUPE_PATTERN;
                  acc.errors.push(err);
                  return $return(acc);
                }

                return loadDoc({
                  cwd
                }).then(function ($await_14) {
                  _ref3 = $await_14, contents = _ref3.contents;
                  return getFiles(source, {
                    cwd: options.cwd
                  }).then(function ($await_15) {
                    acc.patterns.push({
                      id: manifest.name,
                      artifact,
                      contents: contents ? String(contents) : null,
                      contentType: "pattern",
                      source: path.relative(options.cwd, source),
                      files: $await_15,
                      path: relativeManifestPath,
                      manifest,
                      rawManifest: raw,
                      errors: []
                    });
                    return $return(acc);
                  }.$asyncbind(this, $error), $error);
                }.$asyncbind(this, $error), $error);
              }.$asyncbind(this, $error), $error);
            }.$asyncbind(this, $error), $error);
          }.$asyncbind(this)), Promise.resolve({
            errors: [],
            patterns: []
          })).then($return, $error);
        }.$asyncbind(this, $error), $error);
      }.$asyncbind(this, $error), $error);
    }.$asyncbind(this, $error), $error);
  }.$asyncbind(this));
}

function getFiles(source, options) {
  return new Promise(function ($return, $error) {
    var cwd;
    cwd = path.dirname(source);
    return globby(["*", "!package.json", "!pattern.json"], {
      cwd
    }).then(function ($await_17) {
      return $return($await_17.map(file => path.relative(options.cwd, path.join(cwd, file))));
    }.$asyncbind(this, $error), $error);
  }.$asyncbind(this));
}

function getSourceMap(jsFile) {
  return new Promise((resolve, reject) => {
    loadSourceMap(jsFile, (err, sourcemap) => {
      if (err) {
        return reject(err);
      }

      resolve(sourcemap);
    });
  });
}

function json(options) {
  return new Promise(function ($return, $error) {
    var $Try_3_Post = function () {
      return $return();
    }.$asyncbind(this, $error);

    var $Try_3_Catch = function (err) {
      return $return([err]);
    }.$asyncbind(this, $error);

    try {
      return loadManifest(options).then(function ($await_18) {
        return $return([null, $await_18]);
      }.$asyncbind(this, $Try_3_Catch), $Try_3_Catch);
    } catch (err) {
      $Try_3_Catch(err)
    }
  }.$asyncbind(this));
}
//# sourceMappingURL=load-meta.js.map
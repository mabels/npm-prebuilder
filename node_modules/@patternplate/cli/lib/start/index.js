Function.prototype.$asyncbind = function $asyncbind(self, catcher) {
  "use strict";

  if (!Function.prototype.$asyncbind) {
    Object.defineProperty(Function.prototype, "$asyncbind", {
      value: $asyncbind,
      enumerable: false,
      configurable: true,
      writable: true
    });
  }

  if (!$asyncbind.trampoline) {
    $asyncbind.trampoline = function trampoline(t, x, s, e, u) {
      return function b(q) {
        while (q) {
          if (q.then) {
            q = q.then(b, e);
            return u ? undefined : q;
          }

          try {
            if (q.pop) {
              if (q.length) return q.pop() ? x.call(t) : q;
              q = s;
            } else q = q.call(t);
          } catch (r) {
            return e(r);
          }
        }
      };
    };
  }

  if (!$asyncbind.LazyThenable) {
    $asyncbind.LazyThenable = function () {
      function isThenable(obj) {
        return obj && obj instanceof Object && typeof obj.then === "function";
      }

      function resolution(p, r, how) {
        try {
          var x = how ? how(r) : r;
          if (p === x) return p.reject(new TypeError("Promise resolution loop"));

          if (isThenable(x)) {
            x.then(function (y) {
              resolution(p, y);
            }, function (e) {
              p.reject(e);
            });
          } else {
            p.resolve(x);
          }
        } catch (ex) {
          p.reject(ex);
        }
      }

      function Chained() {}

      ;
      Chained.prototype = {
        resolve: _unchained,
        reject: _unchained,
        then: thenChain
      };

      function _unchained(v) {}

      function thenChain(res, rej) {
        this.resolve = res;
        this.reject = rej;
      }

      function then(res, rej) {
        var chain = new Chained();

        try {
          this._resolver(function (value) {
            return isThenable(value) ? value.then(res, rej) : resolution(chain, value, res);
          }, function (ex) {
            resolution(chain, ex, rej);
          });
        } catch (ex) {
          resolution(chain, ex, rej);
        }

        return chain;
      }

      function Thenable(resolver) {
        this._resolver = resolver;
        this.then = then;
      }

      ;

      Thenable.resolve = function (v) {
        return Thenable.isThenable(v) ? v : {
          then: function then(resolve) {
            return resolve(v);
          }
        };
      };

      Thenable.isThenable = isThenable;
      return Thenable;
    }();

    $asyncbind.EagerThenable = $asyncbind.Thenable = ($asyncbind.EagerThenableFactory = function (tick) {
      tick = tick || typeof process === "object" && process.nextTick || typeof setImmediate === "function" && setImmediate || function (f) {
        setTimeout(f, 0);
      };

      var soon = function () {
        var fq = [],
            fqStart = 0,
            bufferSize = 1024;

        function callQueue() {
          while (fq.length - fqStart) {
            try {
              fq[fqStart]();
            } catch (ex) {}

            fq[fqStart++] = undefined;

            if (fqStart === bufferSize) {
              fq.splice(0, bufferSize);
              fqStart = 0;
            }
          }
        }

        return function (fn) {
          fq.push(fn);
          if (fq.length - fqStart === 1) tick(callQueue);
        };
      }();

      function Zousan(func) {
        if (func) {
          var me = this;
          func(function (arg) {
            me.resolve(arg);
          }, function (arg) {
            me.reject(arg);
          });
        }
      }

      Zousan.prototype = {
        resolve: function resolve(value) {
          if (this.state !== undefined) return;
          if (value === this) return this.reject(new TypeError("Attempt to resolve promise with self"));
          var me = this;

          if (value && (typeof value === "function" || typeof value === "object")) {
            try {
              var first = 0;
              var then = value.then;

              if (typeof then === "function") {
                then.call(value, function (ra) {
                  if (!first++) {
                    me.resolve(ra);
                  }
                }, function (rr) {
                  if (!first++) {
                    me.reject(rr);
                  }
                });
                return;
              }
            } catch (e) {
              if (!first) this.reject(e);
              return;
            }
          }

          this.state = STATE_FULFILLED;
          this.v = value;
          if (me.c) soon(function () {
            for (var n = 0, l = me.c.length; n < l; n++) STATE_FULFILLED(me.c[n], value);
          });
        },
        reject: function reject(reason) {
          if (this.state !== undefined) return;
          this.state = STATE_REJECTED;
          this.v = reason;
          var clients = this.c;
          if (clients) soon(function () {
            for (var n = 0, l = clients.length; n < l; n++) STATE_REJECTED(clients[n], reason);
          });
        },
        then: function then(onF, onR) {
          var p = new Zousan();
          var client = {
            y: onF,
            n: onR,
            p: p
          };

          if (this.state === undefined) {
            if (this.c) this.c.push(client);else this.c = [client];
          } else {
            var s = this.state,
                a = this.v;
            soon(function () {
              s(client, a);
            });
          }

          return p;
        }
      };

      function STATE_FULFILLED(c, arg) {
        if (typeof c.y === "function") {
          try {
            var yret = c.y.call(undefined, arg);
            c.p.resolve(yret);
          } catch (err) {
            c.p.reject(err);
          }
        } else c.p.resolve(arg);
      }

      function STATE_REJECTED(c, reason) {
        if (typeof c.n === "function") {
          try {
            var yret = c.n.call(undefined, reason);
            c.p.resolve(yret);
          } catch (err) {
            c.p.reject(err);
          }
        } else c.p.reject(reason);
      }

      Zousan.resolve = function (val) {
        if (val && val instanceof Zousan) return val;
        var z = new Zousan();
        z.resolve(val);
        return z;
      };

      Zousan.reject = function (err) {
        if (err && err instanceof Zousan) return err;
        var z = new Zousan();
        z.reject(err);
        return z;
      };

      Zousan.version = "2.3.3-nodent";
      return Zousan;
    })();
  }

  var resolver = this;

  switch (catcher) {
    case true:
      return new $asyncbind.Thenable(boundThen);

    case 0:
      return new $asyncbind.LazyThenable(boundThen);

    case undefined:
      boundThen.then = boundThen;
      return boundThen;

    default:
      return function () {
        try {
          return resolver.apply(self, arguments);
        } catch (ex) {
          return catcher(ex);
        }
      };
  }

  function boundThen() {
    return resolver.apply(self, arguments);
  }
};

const Path = require("path");

const ora = require("ora");

const debug = require("util").debuglog("PATTERNPLATE");

const importFresh = require("import-fresh");

const readline = require("readline");

const loadConfig = require("@patternplate/load-config");

module.exports = start;

function start({
  flags
}) {
  return new Promise(function ($return, $error) {
    var spinner, cwd, port, rl, restart, chokidar, watcher;
    let beat, failures;
    spinner = ora({
      text: "Starting patternplate server"
    }).start();
    beat = Date.now();
    failures = 0;

    if (process.connected) {
      setInterval(() => {
        const age = Date.now() - beat;

        if (age >= 1000) {
          failures++;
          debug(`start: beat is ${age}ms old, failure ${failures}/3.`);
        } else if (failures !== 0) {
          debug(`start: beat limit met, reset failure to 0/3.`);
          failures = 0;
        }

        if (failures >= 3) {
          console.log(`start: beat failed ${failures} times, shutting down.`);
          process.exit(0);
        }
      }, 1000);
    }

    process.on("message", envelope => {
      try {
        const message = JSON.parse(envelope);

        if (message.type === "heartbeat") {
          beat = Date.now();
        }
      } catch (err) {
        console.error(err);
      }
    });
    cwd = flags.cwd || process.cwd();
    port = selectPort(flags);

    var $Try_2_Post = function () {
      return $return();
    }.$asyncbind(this, $error);

    var $Try_2_Catch = function (err) {
      switch (err.code) {
        case "EADDRINUSE":
          spinner.text = `Starting patternplate server failed`;
          spinner.fail();
          err.message = `Server could not be started, free the port: ${err.message}`;
          err.patternplate = true;
          throw err;

        default:
          throw err;
      }

      return $Try_2_Post();
    }.$asyncbind(this, $error);

    try {
      let app, rlcount;
      return startPatternplate({
        cwd,
        port,
        spinner,
        server: flags.server
      }).then(function ($await_4) {
        app = $await_4;
        rl = readline.createInterface({
          input: process.stdin,
          terminal: false
        });
        rlcount = 0;
        restart = () => new Promise(function ($return, $error) {
          Object.keys(require.cache).forEach(id => {
            delete require.cache[id];
          });
          readline.moveCursor(process.stdin, 0, -1);
          readline.clearLine(process.stdin);
          spinner.text = spinner.text.replace('Started', 'Reloading patternplate');
          spinner.start();
          app.unsubscribe();
          ++rlcount;
          return startPatternplate({
            cwd,
            port,
            spinner,
            count: rlcount,
            reloading: app,
            server: flags.server
          }).then(function ($await_5) {
            app = $await_5;
            return $return();
          }.$asyncbind(this, $error), $error);
        }.$asyncbind(this));
        rl.on("line", line => new Promise(function ($return, $error) {
          if (line.endsWith("rs")) {
            readline.moveCursor(process.stdin, 0, -1);
            readline.clearLine(process.stdin);
            return restart().then(function ($await_6) {
              return $If_3.call(this);
            }.$asyncbind(this, $error), $error);
          }

          function $If_3() {
            return $return();
          }

          return $If_3.call(this);
        }.$asyncbind(this)));

        if (flags.hot) {
          chokidar = require("chokidar");
          watcher = chokidar.watch([...getModules()], {
            ignoreInitial: true,
            ignorePermissionErrors: true
          });
          watcher.on("all", (_, path) => new Promise(function ($return, $error) {
            return restart().then(function ($await_7) {
              watcher.add([...getModules()]);
              return $return();
            }.$asyncbind(this, $error), $error);
          }.$asyncbind(this)));
        }

        return $Try_2_Post();
      }.$asyncbind(this, $Try_2_Catch), $Try_2_Catch);
    } catch (err) {
      $Try_2_Catch(err)
    }
  }.$asyncbind(this));
}

function selectPort(flags) {
  if (!isNaN(Number(flags.port))) {
    return Number(flags.port);
  }

  if (!isNaN(Number(process.env.PORT))) {
    return process.env.PORT;
  }

  return 1337;
}

function startPatternplate(context) {
  return new Promise(function ($return, $error) {
    var port, cwd, spinner, server, count, patternplate, verb, doneVerb, result, _result$config, config, filepath, base, app;

    port = context.port, cwd = context.cwd, spinner = context.spinner, server = context.server;
    count = context.count > 0 ? `(${context.count})` : '';
    patternplate = importFresh("./serve");
    verb = context.reloading ? `reload` : `start`;
    doneVerb = context.reloading ? `Reloaded` : `Started`;
    return loadConfig({
      cwd: context.cwd
    }).then(function ($await_8) {
      result = $await_8;
      _result$config = result.config, config = _result$config === void 0 ? {} : _result$config, filepath = result.filepath;
      base = filepath ? Path.dirname(filepath) : context.cwd;
      return patternplate({
        port,
        server,
        config,
        cwd: base
      }).then(function ($await_9) {
        app = $await_9;
        spinner.text = `${doneVerb} on http://localhost:${app.port} ${count}`;
        spinner.succeed();
        app.subscribe(message => {
          if (message.type === "exception") {
            spinner.text = `Could not ${verb} patternplate on http://localhost:${app.port} ${count}`;
            spinner.fail();
            console.error(message.payload.stderr);
            process.exit(1);
          }

          if (message.type === "error" && message.payload && typeof message.payload.message === "string") {
            spinner.text = message.payload.message;
            spinner.fail();
          }
        });
        return $return(app);
      }.$asyncbind(this, $error), $error);
    }.$asyncbind(this, $error), $error);
  }.$asyncbind(this));
}

function getModules(mod = module, mods = new Set()) {
  if (mods.has(mod.filename)) {
    return mods;
  }

  mods.add(mod.filename);
  mod.children.forEach(child => getModules(child, mods));
  return mods;
}
//# sourceMappingURL=index.js.map
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var Debug = require("debug");
var fs = require("fs");
var glob = require("glob");
var request = require("request");
var commandOptions_1 = require("./commandOptions");
var JsonPointer = require("./jsonPointer");
var schemaid_1 = require("./schemaid");
var typeDefinition_1 = require("./typeDefinition");
var utils_1 = require("./utils");
var writeProcessor_1 = require("./writeProcessor");
var debug = Debug('dtsgen');
var walkMaker = '<<type>>';
var JsonSchemaParser = (function () {
    function JsonSchemaParser() {
        this.typeCache = new Map();
        this.schemaReference = new Map();
        this.referenceCache = new Map();
    }
    JsonSchemaParser.prototype.generateDts = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var _i, _a, typeId, _b, _c, ref, _d, _e, schema, _f, _g, id, process, env;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        debug("generate d.ts.");
                        return [4 /*yield*/, this.resolveReference()];
                    case 1:
                        _h.sent();
                        if (debug.enabled) {
                            debug('TypeId list:');
                            for (_i = 0, _a = Array.from(this.typeCache.keys()); _i < _a.length; _i++) {
                                typeId = _a[_i];
                                debug('  ' + typeId);
                            }
                            debug('SchemaId list:');
                            for (_b = 0, _c = Array.from(this.schemaReference.keys()); _b < _c.length; _b++) {
                                ref = _c[_b];
                                debug('  ' + ref);
                            }
                            debug('Reference list:');
                            for (_d = 0, _e = Array.from(this.referenceCache.keys()); _d < _e.length; _d++) {
                                schema = _e[_d];
                                debug('  ' + schema.id);
                                for (_f = 0, _g = Array.from(this.referenceCache.get(schema).keys()); _f < _g.length; _f++) {
                                    id = _g[_f];
                                    debug('    ' + id);
                                }
                            }
                        }
                        process = new writeProcessor_1.WriteProcessor(function (baseSchema, ref) {
                            debug("Search Reference: schemaId=" + (baseSchema ? baseSchema.id : null) + ", ref=" + ref);
                            var map = _this.referenceCache.get(baseSchema);
                            if (map == null) {
                                return undefined;
                            }
                            var refId = new schemaid_1.SchemaId(ref);
                            var result = map.get(refId.getAbsoluteId());
                            if (result == null) {
                                if (refId.isJsonPointerHash()) {
                                    var fileId = refId.getFileId();
                                    var schema = fileId ? _this.schemaReference.get(fileId).targetSchema : baseSchema;
                                    debug("  fileId=" + fileId + ", schemaId=" + schema.id + ".");
                                    return JsonPointer.get(schema, refId.getJsonPointerHash());
                                }
                            }
                            return result;
                        });
                        env = this.createHierarchicalMap(this.typeCache);
                        if (commandOptions_1.default.header) {
                            process.outputLine(commandOptions_1.default.header);
                        }
                        this.walk(process, env);
                        return [2 /*return*/, process.toDefinition()];
                }
            });
        });
    };
    JsonSchemaParser.prototype.createHierarchicalMap = function (types) {
        var map = {};
        if (types.size === 0) {
            throw new Error('There is no id in the input schema(s)');
        }
        for (var _i = 0, _a = Array.from(types.values()); _i < _a.length; _i++) {
            var type = _a[_i];
            var names = type.schemaId.getTypeNames();
            JsonPointer.set(map, names.concat(walkMaker), type);
        }
        return map;
    };
    JsonSchemaParser.prototype.walk = function (process, env, path) {
        var _this = this;
        if (path === void 0) { path = []; }
        var keys = Object.keys(env).sort();
        keys.forEach(function (key) {
            var val = env[key];
            var type = val[walkMaker];
            if (type instanceof typeDefinition_1.TypeDefinition) {
                debug("  walk doProcess: path=" + JSON.stringify(path) + ", schemaId=" + type.schemaId.getAbsoluteId());
                type.doProcess(process);
            }
            delete val[walkMaker];
            if (Object.keys(val).length > 0) {
                var nextPath = path.concat(key);
                if (process.indentLevel === 0) {
                    process.output('declare ');
                }
                process.output('namespace ').outputType(key, true).outputLine(' {');
                process.increaseIndent();
                _this.walk(process, val, nextPath);
                process.decreaseIndent();
                process.outputLine('}');
            }
        });
    };
    JsonSchemaParser.prototype.resolveReference = function () {
        return __awaiter(this, void 0, void 0, function () {
            var error, _i, _a, schema, map, _b, _c, _d, ref, type, refId, fileId, fetchedSchema, e_1, pointer, targetSchema, typeDef, target;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        debug("resolve reference: reference schema count=" + this.referenceCache.size + ".");
                        error = [];
                        _i = 0, _a = Array.from(this.referenceCache.keys());
                        _e.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 9];
                        schema = _a[_i];
                        map = this.referenceCache.get(schema);
                        _b = 0, _c = Array.from(map.entries());
                        _e.label = 2;
                    case 2:
                        if (!(_b < _c.length)) return [3 /*break*/, 8];
                        _d = _c[_b], ref = _d[0], type = _d[1];
                        if (type != null) {
                            return [3 /*break*/, 7];
                        }
                        refId = new schemaid_1.SchemaId(ref);
                        fileId = refId.getFileId();
                        if (!(fileId && !this.schemaReference.has(fileId))) return [3 /*break*/, 6];
                        if (!refId.isFetchable()) {
                            error.push("$ref target is not found: " + ref);
                            return [3 /*break*/, 7];
                        }
                        _e.label = 3;
                    case 3:
                        _e.trys.push([3, 5, , 6]);
                        debug("fetch remote schema: id=[" + fileId + "].");
                        return [4 /*yield*/, this.fetchRemoteSchema(fileId)];
                    case 4:
                        fetchedSchema = _e.sent();
                        this.parseSchema(fetchedSchema, fileId);
                        return [3 /*break*/, 6];
                    case 5:
                        e_1 = _e.sent();
                        error.push("fail to fetch the $ref target: " + ref + ", " + e_1);
                        return [3 /*break*/, 7];
                    case 6:
                        debug("resolve reference: ref=[" + ref + "]");
                        if (refId.isJsonPointerHash()) {
                            pointer = refId.getJsonPointerHash();
                            targetSchema = fileId ? this.schemaReference.get(fileId).rootSchema : schema;
                            typeDef = new typeDefinition_1.TypeDefinition(targetSchema, pointer, refId);
                            map.set(ref, typeDef);
                            this.addType(typeDef);
                        }
                        else {
                            target = this.typeCache.get(ref);
                            if (target == null) {
                                error.push("$ref target is not found: " + ref);
                                return [3 /*break*/, 7];
                            }
                            map.set(ref, target);
                        }
                        _e.label = 7;
                    case 7:
                        _b++;
                        return [3 /*break*/, 2];
                    case 8:
                        _i++;
                        return [3 /*break*/, 1];
                    case 9:
                        if (error.length > 0) {
                            throw new Error(error.join('\n'));
                        }
                        return [2 /*return*/, true];
                }
            });
        });
    };
    JsonSchemaParser.prototype.fetchLocalFileSchemas = function (globPath) {
        var files = glob.sync(globPath);
        return Promise.all(files.map(function (file) {
            return new Promise(function (resolve, reject) {
                fs.readFile(file, { encoding: 'utf-8' }, function (err, content) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        try {
                            resolve(utils_1.parseFileContent(content, file));
                        }
                        catch (e) {
                            reject(e);
                        }
                    }
                });
            });
        }));
    };
    JsonSchemaParser.prototype.fetchRemoteSchema = function (url) {
        return new Promise(function (resolve, reject) {
            request.get(url, function (err, response, body) {
                if (err) {
                    return reject(err);
                }
                else if (response.statusCode !== 200) {
                    return reject(body);
                }
                else {
                    try {
                        resolve(utils_1.parseFileContent(body, url));
                    }
                    catch (e) {
                        reject(e);
                    }
                }
            });
        });
    };
    JsonSchemaParser.prototype.parseSchema = function (schema, url) {
        var _this = this;
        if (typeof schema === 'string') {
            schema = JSON.parse(schema);
        }
        debug("parse schema: schemaId=[" + schema.id + "], url=[" + url + "].");
        if (schema.id == null) {
            schema.id = url;
        }
        var walk = function (s, paths) {
            function walkArray(array, pathArray) {
                array.forEach(function (item, index) {
                    walk(item, pathArray.concat(index.toString()));
                });
            }
            function walkObject(obj, pathObject, isDefinitions) {
                if (isDefinitions === void 0) { isDefinitions = false; }
                Object.keys(obj).forEach(function (key) {
                    var sub = obj[key];
                    if (sub != null) {
                        if (isDefinitions && sub.id == null) {
                            sub.id = "#/definitions/" + key;
                        }
                        walk(sub, pathObject.concat(key));
                    }
                });
            }
            if (s == null || typeof s !== 'object') {
                return;
            }
            var allOf = s.allOf;
            if (allOf != null) {
                walkArray(allOf, paths.concat('allOf'));
            }
            var anyOf = s.anyOf;
            if (anyOf != null) {
                walkArray(anyOf, paths.concat('anyOf'));
            }
            var oneOf = s.oneOf;
            if (oneOf != null) {
                walkArray(oneOf, paths.concat('oneOf'));
            }
            var items = s.items;
            if (items != null) {
                if (Array.isArray(items)) {
                    walkArray(items, paths.concat('items'));
                }
                else {
                    walk(items, paths.concat('items'));
                }
            }
            var additionalItems = s.additionalItems;
            if (additionalItems != null && typeof additionalItems !== 'boolean') {
                walk(additionalItems, paths.concat('additionalItems'));
            }
            var definitions = s.definitions;
            if (definitions != null) {
                walkObject(s.definitions, paths.concat('definitions'), true);
            }
            var properties = s.properties;
            if (properties != null) {
                walkObject(s.properties, paths.concat('properties'));
            }
            var patternProperties = s.patternProperties;
            if (patternProperties != null) {
                walkObject(s.patternProperties, paths.concat('patternProperties'));
            }
            var additionalProperties = s.additionalProperties;
            if (additionalProperties != null && typeof additionalProperties !== 'boolean') {
                walk(additionalProperties, paths.concat('additionalProperties'));
            }
            if (typeof s.id === 'string') {
                var type = new typeDefinition_1.TypeDefinition(schema, paths);
                s.id = type.schemaId.getAbsoluteId();
                _this.addType(type);
                // debug(`parse schema: id property found, id=[${s.id}], paths=${JSON.stringify(paths)}.`);
            }
            if (typeof s.$ref === 'string') {
                s.$ref = _this.addReference(schema, s.$ref);
                // debug(`parse schema: $ref property found, $ref=[${s.$ref}], paths=${JSON.stringify(paths)}.`);
            }
        };
        walk(schema, []);
    };
    JsonSchemaParser.prototype.addType = function (g) {
        var id = g.schemaId;
        if (id) {
            this.typeCache.set(id.getAbsoluteId(), g);
            debug("add type: id=" + id.getAbsoluteId());
            var fileId = id.getFileId();
            if (!this.schemaReference.has(fileId)) {
                this.schemaReference.set(fileId, g);
            }
        }
    };
    JsonSchemaParser.prototype.addReference = function (schema, ref) {
        var map = this.referenceCache.get(schema);
        if (map == null) {
            map = new Map();
            this.referenceCache.set(schema, map);
        }
        var refId = new schemaid_1.SchemaId(ref, [schema.id]);
        map.set(refId.getAbsoluteId(), null);
        return refId.getAbsoluteId();
    };
    JsonSchemaParser.prototype.clear = function () {
        debug('clear data cache.');
        this.typeCache.clear();
        this.schemaReference.clear();
        this.referenceCache.clear();
    };
    return JsonSchemaParser;
}());
exports.JsonSchemaParser = JsonSchemaParser;

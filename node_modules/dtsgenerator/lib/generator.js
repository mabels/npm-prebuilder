/// <referece path="../typings/tsd.d.ts" />
var pointer = require('json-pointer');
var utils = require("./utils");
var Process = require("./process");
var Generator = (function () {
    function Generator(schema) {
        this.schema = schema;
        this._id = "";
        if (!schema.id) {
            console.error(schema);
            throw new Error("id is not found.");
        }
        this._id = schema.id;
        if (this._id[0] !== "/") {
            this._id = "/" + this._id;
        }
    }
    Generator.generate = function (header) {
        var process = new Process();
        if (header) {
            process.outputLine(header);
        }
        this.walk(process, this.env);
        return process.toDefinition();
    };
    Generator.walk = function (process, env) {
        var _this = this;
        var keys = Object.keys(env).sort();
        keys.forEach(function (key) {
            var val = env[key];
            if (val instanceof Generator) {
                var g = val;
                g.doProcess(process);
            }
            else {
                if (process.indent === 0) {
                    process.output("declare ");
                }
                process.output("module ").output(key).outputLine(" {");
                process.increaseIndent();
                _this.walk(process, val);
                process.decreaseIndent();
                process.outputLine("}");
            }
        });
    };
    Generator.add = function (schema) {
        if (typeof schema === "string") {
            schema = JSON.parse(schema);
        }
        var g = new Generator(schema);
        this.map[g.id] = g;
        this.setEnv(pointer.parse(g.id), g);
    };
    Generator.setEnv = function (paths, g) {
        var obj = this.env;
        var name = paths.splice(paths.length - 1)[0];
        paths.forEach(function (path, i) {
            if (!obj[path]) {
                obj[path] = {};
            }
            obj = obj[path];
        });
        obj[name] = g;
    };
    Generator.clear = function () {
        this.env = {};
        this.map = {};
    };
    Object.defineProperty(Generator.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Generator.prototype.doProcess = function (process) {
        this.parseType(process, this.schema);
    };
    Generator.prototype.getTypename = function (id) {
        var name = id.split("/").slice(-1)[0];
        return utils.capitalizeName(name);
    };
    Generator.prototype.searchRef = function (ref) {
        var splited = ref.split('#', 2);
        var id = splited[0];
        var path = splited[1];
        if (id && !Generator.map[id]) {
            throw new Error("$ref target is not found: " + id);
        }
        if (path[0] && path[0] !== '/') {
            throw new Error("$ref path must be absolute path: " + path);
        }
        var schema = id ? Generator.map[id].schema : this.schema;
        return pointer.get(schema, path);
    };
    Generator.prototype.parseType = function (process, type) {
        if (type.type !== "object" && type.type !== "any" && type.type !== "array") {
            console.error(type);
            throw new Error("unknown type: " + type.type);
        }
        process.outputJSDoc(type.description);
        if (type.type === "array") {
            this.parseTypeCollection(process, type);
        }
        else {
            this.parseTypeModel(process, type);
        }
    };
    Generator.prototype.parseTypeModel = function (process, type) {
        var _this = this;
        var name = this.getTypename(this._id);
        process.output("export interface I").output(name).outputLine(" {");
        process.increaseIndent();
        if (type.type === "any") {
            // TODO this is not permitted property access by dot.
            process.outputLine("[name: string]: any; // any");
        }
        Object.keys(type.properties || {}).forEach(function (propertyName) {
            var property = type.properties[propertyName];
            process.outputJSDoc(property.description);
            if (type.required && type.required.indexOf(propertyName) < 0) {
                propertyName = propertyName + "?";
            }
            _this.parseTypeProperty(process, propertyName, property);
        });
        process.decreaseIndent();
        process.outputLine("}");
    };
    Generator.prototype.parseTypeCollection = function (process, type) {
        var name = this.getTypename(this._id);
        process.output("export interface I").output(name).output(" extends Array<");
        if (type.items.$ref) {
            this.parseTypePropertyNamedType(process, "I" + type.items.$ref, type.items, false);
        }
        else {
            this.parseTypeProperty(process, null, type.items, false);
        }
        process.outputLine("> {");
        process.outputLine("}");
    };
    Generator.prototype.parseTypeProperty = function (process, name, property, terminate) {
        var _this = this;
        if (terminate === void 0) { terminate = true; }
        if (property.allOf) {
            var schema = {};
            property.allOf.forEach(function (p) {
                if (p.$ref) {
                    p = _this.searchRef(p.$ref);
                }
                utils.mergeSchema(schema, p);
            });
            this.parseTypeProperty(process, name, schema, terminate);
            return;
        }
        // TODO I hope to use union type for 'anyOf' support.
        if (property.anyOf) {
            delete property.anyOf;
            property.type = 'any';
        }
        if (property.enum) {
            property.format = property.enum.toString();
            property.type = "any";
        }
        ['oneOf', 'not'].forEach(function (keyword) {
            var schema = property;
            if (schema[keyword]) {
                console.error(property);
                throw new Error("unsupported property: " + keyword);
            }
        });
        if (name) {
            process.outputKey(name).output(": ");
        }
        if (property.$ref) {
            var ref = this.searchRef(property.$ref);
            if (ref) {
                if (ref.id) {
                    this.parseTypePropertyNamedType(process, "I" + this.getTypename(ref.id), ref, terminate);
                }
                else {
                    this.parseTypeProperty(process, null, ref, terminate);
                }
            }
            else {
                this.parseTypePropertyNamedType(process, "I" + property.$ref, property, terminate);
            }
            return;
        }
        var tsType = utils.toTSType(property.type, property);
        if (tsType) {
            this.parseTypePropertyNamedType(process, tsType, property, terminate);
            return;
        }
        if (property.type === "object") {
            process.outputLine("{");
            process.increaseIndent();
            if (property.properties) {
                Object.keys(property.properties).forEach(function (propertyName) {
                    var nextProperty = property.properties[propertyName];
                    if (property.required && property.required.indexOf(propertyName) < 0) {
                        propertyName = propertyName + "?";
                    }
                    _this.parseTypeProperty(process, propertyName, nextProperty);
                });
            }
            else if (property.additionalProperties) {
                process.output("[name:string]: ");
                this.parseTypeProperty(process, null, property.additionalProperties, false);
                process.outputLine(";");
            }
            process.decreaseIndent();
            process.output("}");
            if (terminate) {
                process.outputLine(";");
            }
        }
        else if (property.type === "array") {
            this.parseTypeProperty(process, null, property.items, false);
            process.output("[]");
            if (terminate) {
                process.outputLine(";");
            }
        }
        else {
            console.error(property);
            throw new Error("unknown type: " + property.type);
        }
    };
    Generator.prototype.parseTypePropertyNamedType = function (process, typeName, property, terminate) {
        if (terminate === void 0) { terminate = true; }
        process.output(typeName);
        if (terminate) {
            process.output(";");
            if (property.format) {
                process.output(" // ").output(property.format);
            }
            process.outputLine();
        }
        else {
            if (property.format) {
                process.output(" /* ").output(property.format).output(" */ ");
            }
        }
    };
    Generator.env = {};
    Generator.map = {};
    return Generator;
})();
module.exports = Generator;

//# sourceMappingURL=generator.js.map